{"file_contents":{"Package.swift":{"content":"// swift-tools-version: 5.9\nimport PackageDescription\n\nlet package = Package(\n    name: \"NotapsUnifiedLanguageLearning\",\n    platforms: [\n        .iOS(.v17)\n    ],\n    products: [\n        .executable(\n            name: \"NotapsUnifiedLanguageLearning\",\n            targets: [\"NotapsUnifiedLanguageLearning\"])\n    ],\n    dependencies: [\n        // No external dependencies - using only iOS native frameworks\n    ],\n    targets: [\n        .executableTarget(\n            name: \"NotapsUnifiedLanguageLearning\",\n            dependencies: [],\n            path: \"Sources\",\n            resources: [\n                .copy(\"Resources\")\n            ]\n        )\n    ]\n)","size_bytes":656},"replit.md":{"content":"# Notaps Unified Language Learning\n\n## Overview\n\nNotaps Unified Language Learning is a unified iOS language learning application created by integrating two existing Swift apps: NotapsStudyENJP (English-Japanese vocabulary learning) and SoliloquyMirror (pronunciation practice). The project combines vocabulary learning and pronunciation practice into a single, comprehensive learning platform that operates entirely locally on iPhone devices using Apple Intelligence.\n\nThis repository contains both the native iOS Swift implementation and a web-based demonstration prototype. The web demo simulates the iOS functionality and provides a working preview of the integrated learning experience with vocabulary study, pronunciation practice, progress tracking, and settings management.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## Recent Changes (September 13, 2025)\n\n- ‚úÖ Successfully integrated NotapsStudyENJP and SoliloquyMirror functionality into unified app structure\n- ‚úÖ Created comprehensive web demo running on port 5000 with Express.js backend\n- ‚úÖ Implemented SwiftUI-based iOS app architecture with speech recognition and TTS services\n- ‚úÖ Developed multilingual vocabulary system supporting English, Japanese, Korean, French, and Chinese\n- ‚úÖ Added pronunciation practice with simulated accuracy scoring and feedback\n- ‚úÖ Created progress tracking system with learning statistics and achievement metrics\n- üîß Architecture review completed: Core functionality working, some iOS integrations need refinement\n\n## System Architecture\n\n### Native iOS Architecture (Swift/SwiftUI)\nThe main iOS application follows modern SwiftUI patterns with:\n\n- **SwiftUI App Structure**: Main app (`NotapsUnifiedApp.swift`) with tabbed interface and navigation\n- **Service Layer**: Speech recognition (`SpeechRecognizer.swift`) and text-to-speech (`TTSService.swift`) services\n- **Data Models**: Vocabulary and progress models (`VocabularyModels.swift`) with Core Data integration\n- **Apple Intelligence Integration**: On-device speech processing and pronunciation analysis\n- **Local Storage**: All data stored locally using Core Data for vocabulary and progress tracking\n\n### Web Demo Architecture (Node.js/Express)\nThe demonstration web application uses a vanilla JavaScript SPA architecture:\n\n- **Component-based Structure**: Single `NotapsApp` class managing tabs (dashboard, vocabulary, pronunciation, progress, settings)\n- **Mobile-first Design**: CSS styled for mobile devices with 420px max-width to simulate iOS experience\n- **Progressive Enhancement**: Modern JavaScript with graceful fallbacks for older browsers\n- **State Management**: Local state management with browser API persistence\n\n### Demo Backend Architecture\nThe web demo backend uses Express.js for simulation:\n\n- **RESTful API Simulation**: Express server providing JSON endpoints for vocabulary and progress data\n- **Static File Serving**: Serves demo frontend assets from public directory\n- **CORS Enabled**: Configured for development and testing purposes\n- **In-memory Sample Data**: Hardcoded multilingual vocabulary for demonstration\n- **Pronunciation Analysis Simulation**: Text similarity algorithm simulating speech recognition\n\n### Data Model\nThe vocabulary data structure supports multilingual learning with:\n\n- **Hierarchical Translation System**: Each word contains translations for multiple languages with pronunciation guides\n- **Metadata Support**: Includes difficulty levels, categories, and learning progress tracking\n- **Extensible Schema**: Designed to accommodate additional languages and learning metrics\n\n### User Interface Design\nThe interface employs a native mobile app aesthetic:\n\n- **Tab-based Navigation**: Five main sections (Dashboard, Vocabulary, Pronunciation, Progress, Settings)\n- **Japanese Localization**: Primary UI language is Japanese with emoji-enhanced navigation\n- **Responsive Components**: Grid-based layouts that adapt to different screen sizes\n- **Accessibility Features**: Semantic HTML structure and keyboard navigation support\n\n## External Dependencies\n\n### iOS Native Dependencies\n- **SwiftUI**: User interface framework for iOS app development\n- **Speech Framework**: Apple's speech recognition and synthesis APIs\n- **Core Data**: Local data persistence and management\n- **Core ML**: Machine learning model integration for pronunciation analysis\n- **StoreKit 2**: In-app purchase and subscription management\n- **AVFoundation**: Audio session management and media handling\n\n### Web Demo Dependencies\n- **Express.js (^4.18.2)**: Web server framework for demo backend\n- **CORS (^2.8.5)**: Cross-Origin Resource Sharing middleware\n- **Path (^0.12.7)**: Node.js path utilities for file operations\n\n### Browser APIs (Demo)\n- **Web Speech API**: Browser speech recognition and synthesis (planned enhancement)\n- **Local Storage API**: Demo progress and settings persistence\n- **Fetch API**: Communication between frontend and backend services\n\n### Revenue Model Integration\n- **StoreKit 2**: Premium feature unlocking via App Store purchases\n- **Apple Intelligence**: Local processing ensures privacy and reduces server costs\n- **Freemium Model**: Basic features free, advanced pronunciation analysis and unlimited vocabulary via premium upgrade","size_bytes":5299},"Sources/main.swift":{"content":"import SwiftUI\n\n// Main content view for the unified language learning app\nstruct ContentView: View {\n    @EnvironmentObject var speechAuthManager: SpeechAuthManager\n    @EnvironmentObject var audioSessionManager: AudioSessionManager\n    @EnvironmentObject var learningProgressManager: LearningProgressManager\n    \n    @State private var selectedTab = 0\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Home/Dashboard Tab\n            DashboardView()\n                .tabItem {\n                    Image(systemName: \"house.fill\")\n                    Text(\"„Éõ„Éº„É†\")\n                }\n                .tag(0)\n            \n            // Vocabulary Learning Tab\n            VocabularyView()\n                .tabItem {\n                    Image(systemName: \"book.fill\")\n                    Text(\"Ë™ûÂΩô\")\n                }\n                .tag(1)\n            \n            // Pronunciation Practice Tab\n            PronunciationView()\n                .tabItem {\n                    Image(systemName: \"mic.fill\")\n                    Text(\"Áô∫Èü≥\")\n                }\n                .tag(2)\n            \n            // Progress Tracking Tab\n            ProgressView()\n                .tabItem {\n                    Image(systemName: \"chart.line.uptrend.xyaxis\")\n                    Text(\"ÈÄ≤Êçó\")\n                }\n                .tag(3)\n            \n            // Settings Tab\n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gearshape.fill\")\n                    Text(\"Ë®≠ÂÆö\")\n                }\n                .tag(4)\n        }\n        .accentColor(.blue)\n        .onAppear {\n            learningProgressManager.loadProgress()\n        }\n    }\n}\n\n// MARK: - Dashboard View\nstruct DashboardView: View {\n    @EnvironmentObject var learningProgressManager: LearningProgressManager\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    // Welcome Section\n                    VStack(alignment: .leading, spacing: 10) {\n                        Text(\"‰ªäÊó•„ÅÆÂ≠¶Áøí\")\n                            .font(.title2)\n                            .fontWeight(.bold)\n                        \n                        Text(\"Á∂ôÁ∂ö„ÅØÂäõ„Å™„Çä - ‰ªäÊó•„ÇÇÈ†ëÂºµ„Çä„Åæ„Åó„Çá„ÅÜÔºÅ\")\n                            .font(.subheadline)\n                            .foregroundColor(.secondary)\n                    }\n                    .frame(maxWidth: .infinity, alignment: .leading)\n                    .padding()\n                    .background(Color(.systemGray6))\n                    .cornerRadius(12)\n                    \n                    // Quick Stats\n                    HStack(spacing: 15) {\n                        StatCard(title: \"„É¨„Éô„É´\", value: \"\\(learningProgressManager.currentLevel)\", color: .blue)\n                        StatCard(title: \"ÂÆå‰∫Ü\", value: \"\\(learningProgressManager.completedLessons)\", color: .green)\n                        StatCard(title: \"Áô∫Èü≥\", value: String(format: \"%.1f%%\", learningProgressManager.pronunciationScore), color: .orange)\n                    }\n                    \n                    // Quick Actions\n                    VStack(spacing: 15) {\n                        Text(\"„ÇØ„Ç§„ÉÉ„ÇØ„Ç¢„ÇØ„Ç∑„Éß„É≥\")\n                            .font(.headline)\n                            .frame(maxWidth: .infinity, alignment: .leading)\n                        \n                        LazyVGrid(columns: [\n                            GridItem(.flexible()),\n                            GridItem(.flexible())\n                        ], spacing: 15) {\n                            QuickActionCard(\n                                title: \"‰ªäÊó•„ÅÆÂçòË™û\",\n                                subtitle: \"Êñ∞„Åó„ÅÑË™ûÂΩô„ÇíÂ≠¶„Å∂\",\n                                icon: \"book.fill\",\n                                color: .purple\n                            )\n                            \n                            QuickActionCard(\n                                title: \"Áô∫Èü≥Á∑¥Áøí\",\n                                subtitle: \"Èü≥Â£∞Ë™çË≠ò„ÅßÁ∑¥Áøí\",\n                                icon: \"mic.fill\",\n                                color: .red\n                            )\n                            \n                            QuickActionCard(\n                                title: \"Âæ©Áøí\",\n                                subtitle: \"Êó¢ÁøíÂçòË™û„ÅÆÂæ©Áøí\",\n                                icon: \"arrow.clockwise\",\n                                color: .blue\n                            )\n                            \n                            QuickActionCard(\n                                title: \"„ÉÜ„Çπ„Éà\",\n                                subtitle: \"ÁêÜËß£Â∫¶„ÉÅ„Çß„ÉÉ„ÇØ\",\n                                icon: \"checkmark.circle.fill\",\n                                color: .green\n                            )\n                        }\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Notaps Learning\")\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(color)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemGray6))\n        .cornerRadius(8)\n    }\n}\n\nstruct QuickActionCard: View {\n    let title: String\n    let subtitle: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        VStack(spacing: 8) {\n            Image(systemName: icon)\n                .font(.largeTitle)\n                .foregroundColor(color)\n            \n            Text(title)\n                .font(.headline)\n                .fontWeight(.semibold)\n            \n            Text(subtitle)\n                .font(.caption)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n        }\n        .frame(maxWidth: .infinity, minHeight: 120)\n        .padding()\n        .background(Color(.systemGray6))\n        .cornerRadius(12)\n    }\n}\n\n// MARK: - Placeholder Views (will be implemented in detail later)\nstruct VocabularyView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Ë™ûÂΩôÂ≠¶Áøí\")\n                    .font(.largeTitle)\n                    .padding()\n                Text(\"Â§öË®ÄË™ûËæûÊõ∏„Ç∑„Çπ„ÉÜ„É†ÔºàÂÆüË£Ö‰∫àÂÆöÔºâ\")\n                    .foregroundColor(.secondary)\n            }\n            .navigationTitle(\"Vocabulary\")\n        }\n    }\n}\n\nstruct PronunciationView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Áô∫Èü≥Á∑¥Áøí\")\n                    .font(.largeTitle)\n                    .padding()\n                Text(\"Apple IntelligenceÈü≥Â£∞ÂàÜÊûêÔºàÂÆüË£Ö‰∫àÂÆöÔºâ\")\n                    .foregroundColor(.secondary)\n            }\n            .navigationTitle(\"Pronunciation\")\n        }\n    }\n}\n\nstruct ProgressView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Â≠¶ÁøíÈÄ≤Êçó\")\n                    .font(.largeTitle)\n                    .padding()\n                Text(\"Core DataÁµ±Ë®àÔºàÂÆüË£Ö‰∫àÂÆöÔºâ\")\n                    .foregroundColor(.secondary)\n            }\n            .navigationTitle(\"Progress\")\n        }\n    }\n}\n\nstruct SettingsView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Ë®≠ÂÆö\")\n                    .font(.largeTitle)\n                    .padding()\n                Text(\"„Ç¢„Éó„É™Ë®≠ÂÆö„Å®„Éó„É¨„Éü„Ç¢„É†Ê©üËÉΩÔºàÂÆüË£Ö‰∫àÂÆöÔºâ\")\n                    .foregroundColor(.secondary)\n            }\n            .navigationTitle(\"Settings\")\n        }\n    }\n}","size_bytes":8028},"demo/server.js":{"content":"const express = require('express');\nconst path = require('path');\nconst cors = require('cors');\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\n// Sample vocabulary data (simulating the multilingual dictionary)\nconst sampleVocabulary = [\n    {\n        id: 1,\n        word: \"hello\",\n        pronunciation: \"h…ôÀàlo ä\",\n        definition: \"a greeting\",\n        language: \"en\",\n        translations: {\n            ja: { word: \"„Åì„Çì„Å´„Å°„ÅØ\", pronunciation: \"konnichiwa\", definition: \"Êå®Êã∂\" },\n            ko: { word: \"ÏïàÎÖïÌïòÏÑ∏Ïöî\", pronunciation: \"annyeonghaseyo\", definition: \"Ïù∏ÏÇ¨Îßê\" },\n            fr: { word: \"bonjour\", pronunciation: \"bonÀà í ä…ôr\", definition: \"salutation\" },\n            zh: { word: \"‰Ω†Â•Ω\", pronunciation: \"n«ê h«éo\", definition: \"ÈóÆÂÄôËØ≠\" }\n        },\n        difficulty: \"beginner\",\n        category: \"greetings\"\n    },\n    {\n        id: 2,\n        word: \"beautiful\",\n        pronunciation: \"Ààbjut…™f…ôl\",\n        definition: \"pleasing the senses or mind aesthetically\",\n        language: \"en\",\n        translations: {\n            ja: { word: \"Áæé„Åó„ÅÑ\", pronunciation: \"utsukushii\", definition: \"ÁæéÁöÑ„Å´ÊÑüË¶ö„ÇÑÂøÉ„ÇíÂñú„Å∞„Åõ„Çã\" },\n            ko: { word: \"ÏïÑÎ¶ÑÎã§Ïö¥\", pronunciation: \"areumdaun\", definition: \"Í∞êÍ∞ÅÏù¥ÎÇò ÎßàÏùåÏùÑ ÎØ∏Ï†ÅÏúºÎ°ú Í∏∞ÏÅòÍ≤å ÌïòÎäî\" },\n            fr: { word: \"beau/belle\", pronunciation: \"bo/b…õl\", definition: \"qui pla√Æt aux sens ou √† l'esprit\" },\n            zh: { word: \"Áæé‰∏Ω\", pronunciation: \"mƒõi l√¨\", definition: \"Âú®ÁæéÂ≠¶‰∏ä‰ª§ÊÑüÂÆòÊàñÂøÉÁÅµÊÑâÊÇ¶ÁöÑ\" }\n        },\n        difficulty: \"intermediate\",\n        category: \"adjectives\"\n    },\n    {\n        id: 3,\n        word: \"opportunity\",\n        pronunciation: \"Àå…íp…ôÀàtun…™ti\",\n        definition: \"a set of circumstances that makes it possible to do something\",\n        language: \"en\",\n        translations: {\n            ja: { word: \"Ê©ü‰ºö\", pronunciation: \"kikai\", definition: \"‰Ωï„Åã„Çí„Åô„Çã„Åì„Å®„ÇíÂèØËÉΩ„Å´„Åô„ÇãÁä∂Ê≥Å\" },\n            ko: { word: \"Í∏∞Ìöå\", pronunciation: \"gihoe\", definition: \"Ïñ¥Îñ§ ÏùºÏùÑ Ìï† Ïàò ÏûàÍ≤å Ìï¥Ï£ºÎäî ÏÉÅÌô©\" },\n            fr: { word: \"opportunit√©\", pronunciation: \"…îp…î ÅtyniÀàte\", definition: \"ensemble de circonstances qui rend possible de faire quelque chose\" },\n            zh: { word: \"Êú∫‰ºö\", pronunciation: \"jƒ´ hu√¨\", definition: \"‰ΩøÊüê‰∫ãÊàê‰∏∫ÂèØËÉΩÁöÑ‰∏ÄÁ≥ªÂàóÊÉÖÂÜµ\" }\n        },\n        difficulty: \"advanced\",\n        category: \"nouns\"\n    }\n];\n\n// Sample learning progress data\nlet learningProgress = {\n    currentLevel: 2,\n    completedLessons: 15,\n    pronunciationScore: 78.5,\n    vocabularyMastered: 42,\n    totalStudyTime: 1250, // minutes\n    streakDays: 7\n};\n\n// API Routes\napp.get('/api/vocabulary', (req, res) => {\n    const { language, difficulty, limit } = req.query;\n    let vocabulary = [...sampleVocabulary];\n    \n    if (language && language !== 'all') {\n        vocabulary = vocabulary.filter(word => word.language === language);\n    }\n    \n    if (difficulty && difficulty !== 'all') {\n        vocabulary = vocabulary.filter(word => word.difficulty === difficulty);\n    }\n    \n    if (limit) {\n        vocabulary = vocabulary.slice(0, parseInt(limit));\n    }\n    \n    res.json(vocabulary);\n});\n\napp.get('/api/progress', (req, res) => {\n    res.json(learningProgress);\n});\n\napp.post('/api/practice/pronunciation', (req, res) => {\n    const { targetText, spokenText } = req.body;\n    \n    // Simulate pronunciation analysis (in real app, this would use speech recognition)\n    const similarity = calculateTextSimilarity(targetText.toLowerCase(), spokenText.toLowerCase());\n    const accuracy = similarity * 100;\n    \n    let feedback = \"\";\n    if (accuracy >= 90) {\n        feedback = \"ÂÆåÁíß„Åß„ÅôÔºÅÁ¥†Êô¥„Çâ„Åó„ÅÑÁô∫Èü≥„Åß„Åô„Å≠„ÄÇ\";\n    } else if (accuracy >= 80) {\n        feedback = \"„Å®„Å¶„ÇÇËâØ„ÅÑÁô∫Èü≥„Åß„Åô„ÄÇÂ∞ë„ÅóÁ∑¥Áøí„Åô„Çå„Å∞„Åï„Çâ„Å´ËâØ„Åè„Å™„Çä„Åæ„Åô„ÄÇ\";\n    } else if (accuracy >= 70) {\n        feedback = \"ËâØ„ÅÑÁô∫Èü≥„Åß„Åô„ÄÇ„ÇÇ„ÅÜÂ∞ë„ÅóÁ∑¥Áøí„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ\";\n    } else if (accuracy >= 60) {\n        feedback = \"„Åæ„Åö„Åæ„Åö„ÅÆÁô∫Èü≥„Åß„Åô„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\";\n    } else {\n        feedback = \"„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÇÜ„Å£„Åè„ÇäÁô∫Èü≥„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\";\n    }\n    \n    const analysis = {\n        targetText,\n        spokenText,\n        accuracy: Math.round(accuracy),\n        feedback,\n        grade: accuracy >= 90 ? 'A' : accuracy >= 80 ? 'B' : accuracy >= 70 ? 'C' : accuracy >= 60 ? 'D' : 'F'\n    };\n    \n    res.json(analysis);\n});\n\napp.post('/api/progress/update', (req, res) => {\n    const { lesson, score, timeSpent } = req.body;\n    \n    // Update progress (in real app, this would update Core Data)\n    if (score > learningProgress.pronunciationScore) {\n        learningProgress.pronunciationScore = score;\n    }\n    learningProgress.completedLessons += 1;\n    learningProgress.totalStudyTime += timeSpent || 5;\n    \n    res.json(learningProgress);\n});\n\n// Serve main app\napp.get('/', (req, res) => {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\n// Helper function to calculate text similarity (simplified Levenshtein distance)\nfunction calculateTextSimilarity(str1, str2) {\n    const matrix = [];\n    \n    if (str1.length === 0) return str2.length === 0 ? 1 : 0;\n    if (str2.length === 0) return 0;\n    \n    for (let i = 0; i <= str2.length; i++) {\n        matrix[i] = [i];\n    }\n    \n    for (let j = 0; j <= str1.length; j++) {\n        matrix[0][j] = j;\n    }\n    \n    for (let i = 1; i <= str2.length; i++) {\n        for (let j = 1; j <= str1.length; j++) {\n            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            } else {\n                matrix[i][j] = Math.min(\n                    matrix[i - 1][j - 1] + 1,\n                    matrix[i][j - 1] + 1,\n                    matrix[i - 1][j] + 1\n                );\n            }\n        }\n    }\n    \n    const distance = matrix[str2.length][str1.length];\n    const maxLength = Math.max(str1.length, str2.length);\n    return maxLength === 0 ? 1 : Math.max(0, 1 - distance / maxLength);\n}\n\napp.listen(PORT, '0.0.0.0', () => {\n    console.log(`üöÄ Notaps Unified Language Learning Demo running on port ${PORT}`);\n    console.log(`üì± Access the app at: http://localhost:${PORT}`);\n    console.log(`üéØ Features: Vocabulary Learning + Pronunciation Practice`);\n    console.log(`üîß Environment: Demo Web Version (iOS Swift logic simulated)`);\n});","size_bytes":6623},"Sources/App/NotapsUnifiedApp.swift":{"content":"import SwiftUI\nimport Speech\nimport AVFoundation\n\n@main\nstruct NotapsUnifiedApp: App {\n    @StateObject private var speechAuthManager = SpeechAuthManager()\n    @StateObject private var audioSessionManager = AudioSessionManager()\n    @StateObject private var learningProgressManager = LearningProgressManager()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(speechAuthManager)\n                .environmentObject(audioSessionManager)\n                .environmentObject(learningProgressManager)\n                .onAppear {\n                    setupApp()\n                }\n        }\n    }\n    \n    private func setupApp() {\n        // Audio session setup for speech recognition and TTS\n        audioSessionManager.configureAudioSession()\n        \n        // Request speech recognition permissions\n        speechAuthManager.requestSpeechAuthorization()\n    }\n}\n\n// MARK: - Authentication and Permission Managers\n@MainActor\nclass SpeechAuthManager: ObservableObject {\n    @Published var speechAuthorizationStatus: SFSpeechRecognizerAuthorizationStatus = .notDetermined\n    \n    func requestSpeechAuthorization() {\n        SFSpeechRecognizer.requestAuthorization { status in\n            DispatchQueue.main.async {\n                self.speechAuthorizationStatus = status\n            }\n        }\n    }\n}\n\n@MainActor\nclass AudioSessionManager: ObservableObject {\n    @Published var isAudioSessionConfigured = false\n    \n    func configureAudioSession() {\n        do {\n            let audioSession = AVAudioSession.sharedInstance()\n            try audioSession.setCategory(.playAndRecord, mode: .default, options: [.defaultToSpeaker])\n            try audioSession.setActive(true)\n            isAudioSessionConfigured = true\n        } catch {\n            print(\"Audio session configuration failed: \\(error)\")\n            isAudioSessionConfigured = false\n        }\n    }\n}\n\n@MainActor\nclass LearningProgressManager: ObservableObject {\n    @Published var currentLevel: Int = 1\n    @Published var completedLessons: Int = 0\n    @Published var pronunciationScore: Double = 0.0\n    @Published var vocabularyMastered: Int = 0\n    \n    // Save learning progress locally (Core Data integration will be added later)\n    func updateProgress(level: Int, lessons: Int, score: Double, vocabulary: Int) {\n        currentLevel = level\n        completedLessons = lessons\n        pronunciationScore = score\n        vocabularyMastered = vocabulary\n        \n        // TODO: Save to Core Data\n        saveProgressToUserDefaults()\n    }\n    \n    private func saveProgressToUserDefaults() {\n        let defaults = UserDefaults.standard\n        defaults.set(currentLevel, forKey: \"currentLevel\")\n        defaults.set(completedLessons, forKey: \"completedLessons\")\n        defaults.set(pronunciationScore, forKey: \"pronunciationScore\")\n        defaults.set(vocabularyMastered, forKey: \"vocabularyMastered\")\n    }\n    \n    func loadProgress() {\n        let defaults = UserDefaults.standard\n        currentLevel = defaults.integer(forKey: \"currentLevel\")\n        completedLessons = defaults.integer(forKey: \"completedLessons\")\n        pronunciationScore = defaults.double(forKey: \"pronunciationScore\")\n        vocabularyMastered = defaults.integer(forKey: \"vocabularyMastered\")\n    }\n}","size_bytes":3314},"Sources/Models/VocabularyModels.swift":{"content":"import Foundation\nimport SwiftUI\n\n// MARK: - Core Vocabulary Models\nstruct VocabularyWord: Identifiable, Codable, Hashable {\n    let id: UUID\n    let word: String\n    let pronunciation: String\n    let phonetics: String?\n    let definition: String\n    let example: String?\n    let language: LanguageCode\n    let difficulty: DifficultyLevel\n    let category: String\n    let translations: [LanguageCode: Translation]\n    \n    init(\n        word: String,\n        pronunciation: String,\n        phonetics: String? = nil,\n        definition: String,\n        example: String? = nil,\n        language: LanguageCode,\n        difficulty: DifficultyLevel,\n        category: String,\n        translations: [LanguageCode: Translation] = [:]\n    ) {\n        self.id = UUID()\n        self.word = word\n        self.pronunciation = pronunciation\n        self.phonetics = phonetics\n        self.definition = definition\n        self.example = example\n        self.language = language\n        self.difficulty = difficulty\n        self.category = category\n        self.translations = translations\n    }\n}\n\nstruct Translation: Codable, Hashable {\n    let word: String\n    let pronunciation: String\n    let phonetics: String?\n    let definition: String\n    let example: String?\n}\n\nenum LanguageCode: String, CaseIterable, Codable {\n    case english = \"en\"\n    case japanese = \"ja\"\n    case korean = \"ko\"\n    case french = \"fr\"\n    case chinese = \"zh\"\n    \n    var displayName: String {\n        switch self {\n        case .english: return \"English\"\n        case .japanese: return \"Êó•Êú¨Ë™û\"\n        case .korean: return \"ÌïúÍµ≠Ïñ¥\"\n        case .french: return \"Fran√ßais\"\n        case .chinese: return \"‰∏≠Êñá\"\n        }\n    }\n    \n    var speechCode: String {\n        switch self {\n        case .english: return \"en-US\"\n        case .japanese: return \"ja-JP\"\n        case .korean: return \"ko-KR\"\n        case .french: return \"fr-FR\"\n        case .chinese: return \"zh-CN\"\n        }\n    }\n}\n\nenum DifficultyLevel: String, CaseIterable, Codable {\n    case beginner = \"beginner\"\n    case intermediate = \"intermediate\"\n    case advanced = \"advanced\"\n    \n    var displayName: String {\n        switch self {\n        case .beginner: return \"ÂàùÁ¥ö\"\n        case .intermediate: return \"‰∏≠Á¥ö\"\n        case .advanced: return \"‰∏äÁ¥ö\"\n        }\n    }\n    \n    var color: Color {\n        switch self {\n        case .beginner: return .green\n        case .intermediate: return .orange\n        case .advanced: return .red\n        }\n    }\n}\n\n// MARK: - Learning Progress Models\nstruct LearningProgress: Codable {\n    let wordId: UUID\n    var studyCount: Int\n    var correctCount: Int\n    var lastStudied: Date\n    var masteryLevel: MasteryLevel\n    var pronunciationScores: [Float]\n    \n    var accuracy: Double {\n        guard studyCount > 0 else { return 0.0 }\n        return Double(correctCount) / Double(studyCount)\n    }\n    \n    var averagePronunciationScore: Float {\n        guard !pronunciationScores.isEmpty else { return 0.0 }\n        return pronunciationScores.reduce(0, +) / Float(pronunciationScores.count)\n    }\n    \n    mutating func recordStudy(correct: Bool, pronunciationScore: Float? = nil) {\n        studyCount += 1\n        if correct {\n            correctCount += 1\n        }\n        \n        if let score = pronunciationScore {\n            pronunciationScores.append(score)\n            if pronunciationScores.count > 10 {\n                pronunciationScores.removeFirst()\n            }\n        }\n        \n        lastStudied = Date()\n        updateMasteryLevel()\n    }\n    \n    private mutating func updateMasteryLevel() {\n        let recentAccuracy = accuracy\n        let recentPronunciation = averagePronunciationScore\n        \n        if studyCount >= 5 && recentAccuracy >= 0.9 && recentPronunciation >= 80 {\n            masteryLevel = .mastered\n        } else if studyCount >= 3 && recentAccuracy >= 0.7 && recentPronunciation >= 60 {\n            masteryLevel = .learning\n        } else {\n            masteryLevel = .studying\n        }\n    }\n}\n\nenum MasteryLevel: String, CaseIterable, Codable {\n    case new = \"new\"\n    case studying = \"studying\"\n    case learning = \"learning\"\n    case mastered = \"mastered\"\n    \n    var displayName: String {\n        switch self {\n        case .new: return \"Êñ∞Ë¶è\"\n        case .studying: return \"Â≠¶Áøí‰∏≠\"\n        case .learning: return \"ÁøíÂæó‰∏≠\"\n        case .mastered: return \"ÁøíÂæóÊ∏à„Åø\"\n        }\n    }\n    \n    var color: Color {\n        switch self {\n        case .new: return .gray\n        case .studying: return .blue\n        case .learning: return .orange\n        case .mastered: return .green\n        }\n    }\n}\n\n// MARK: - Study Session Models\nstruct StudySession: Identifiable, Codable {\n    let id: UUID\n    let startTime: Date\n    var endTime: Date?\n    var wordsStudied: [UUID]\n    var correctAnswers: Int\n    var totalAnswers: Int\n    var averagePronunciationScore: Float\n    var sessionType: SessionType\n    \n    init(sessionType: SessionType) {\n        self.id = UUID()\n        self.startTime = Date()\n        self.wordsStudied = []\n        self.correctAnswers = 0\n        self.totalAnswers = 0\n        self.averagePronunciationScore = 0.0\n        self.sessionType = sessionType\n    }\n    \n    var duration: TimeInterval {\n        return (endTime ?? Date()).timeIntervalSince(startTime)\n    }\n    \n    var accuracy: Double {\n        guard totalAnswers > 0 else { return 0.0 }\n        return Double(correctAnswers) / Double(totalAnswers)\n    }\n    \n    mutating func recordAnswer(correct: Bool, pronunciationScore: Float? = nil) {\n        totalAnswers += 1\n        if correct {\n            correctAnswers += 1\n        }\n        \n        if let score = pronunciationScore {\n            let currentTotal = averagePronunciationScore * Float(totalAnswers - 1)\n            averagePronunciationScore = (currentTotal + score) / Float(totalAnswers)\n        }\n    }\n    \n    mutating func endSession() {\n        endTime = Date()\n    }\n}\n\nenum SessionType: String, CaseIterable, Codable {\n    case vocabulary = \"vocabulary\"\n    case pronunciation = \"pronunciation\"\n    case mixed = \"mixed\"\n    case review = \"review\"\n    \n    var displayName: String {\n        switch self {\n        case .vocabulary: return \"Ë™ûÂΩôÂ≠¶Áøí\"\n        case .pronunciation: return \"Áô∫Èü≥Á∑¥Áøí\"\n        case .mixed: return \"Á∑èÂêàÂ≠¶Áøí\"\n        case .review: return \"Âæ©Áøí\"\n        }\n    }\n}\n\n// MARK: - Lesson Models\nstruct Lesson: Identifiable, Codable {\n    let id: UUID\n    let title: String\n    let description: String\n    let difficulty: DifficultyLevel\n    let targetLanguage: LanguageCode\n    let sourceLanguage: LanguageCode\n    let words: [UUID] // References to VocabularyWord IDs\n    let estimatedDuration: TimeInterval\n    let category: String\n    \n    init(\n        title: String,\n        description: String,\n        difficulty: DifficultyLevel,\n        targetLanguage: LanguageCode,\n        sourceLanguage: LanguageCode,\n        words: [UUID],\n        estimatedDuration: TimeInterval,\n        category: String\n    ) {\n        self.id = UUID()\n        self.title = title\n        self.description = description\n        self.difficulty = difficulty\n        self.targetLanguage = targetLanguage\n        self.sourceLanguage = sourceLanguage\n        self.words = words\n        self.estimatedDuration = estimatedDuration\n        self.category = category\n    }\n}","size_bytes":7390},"Sources/Services/SpeechRecognizer.swift":{"content":"import Speech\nimport AVFoundation\nimport SwiftUI\n\n@MainActor\nclass SpeechRecognizer: NSObject, ObservableObject {\n    @Published var isRecording = false\n    @Published var recognizedText = \"\"\n    @Published var confidence: Float = 0.0\n    @Published var errorMessage = \"\"\n    \n    private var audioEngine = AVAudioEngine()\n    private var speechRecognizer: SFSpeechRecognizer?\n    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?\n    private var recognitionTask: SFSpeechRecognitionTask?\n    \n    // Supported languages for speech recognition\n    private let supportedLanguages = [\"en-US\", \"ja-JP\", \"ko-KR\", \"fr-FR\", \"zh-CN\"]\n    @Published var currentLanguage = \"en-US\"\n    \n    override init() {\n        super.init()\n        setupSpeechRecognizer()\n    }\n    \n    private func setupSpeechRecognizer() {\n        speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: currentLanguage))\n        speechRecognizer?.delegate = self\n    }\n    \n    func changeLanguage(to languageCode: String) {\n        guard supportedLanguages.contains(languageCode) else {\n            errorMessage = \"Unsupported language: \\(languageCode)\"\n            return\n        }\n        \n        stopRecording()\n        currentLanguage = languageCode\n        setupSpeechRecognizer()\n    }\n    \n    func startRecording() {\n        // Check authorization\n        guard SFSpeechRecognizer.authorizationStatus() == .authorized else {\n            errorMessage = \"Speech recognition not authorized\"\n            return\n        }\n        \n        // Check if speech recognizer is available\n        guard let speechRecognizer = speechRecognizer, speechRecognizer.isAvailable else {\n            errorMessage = \"Speech recognizer not available\"\n            return\n        }\n        \n        // Cancel any existing task\n        stopRecording()\n        \n        // Configure audio session\n        do {\n            let audioSession = AVAudioSession.sharedInstance()\n            try audioSession.setCategory(.record, mode: .measurement, options: .duckOthers)\n            try audioSession.setActive(true, options: .notifyOthersOnDeactivation)\n        } catch {\n            errorMessage = \"Audio session configuration failed: \\(error.localizedDescription)\"\n            return\n        }\n        \n        // Create recognition request\n        recognitionRequest = SFSpeechAudioBufferRecognitionRequest()\n        guard let recognitionRequest = recognitionRequest else {\n            errorMessage = \"Unable to create recognition request\"\n            return\n        }\n        \n        recognitionRequest.shouldReportPartialResults = true\n        recognitionRequest.requiresOnDeviceRecognition = true // For privacy\n        \n        // Configure audio engine\n        let inputNode = audioEngine.inputNode\n        let recordingFormat = inputNode.outputFormat(forBus: 0)\n        \n        inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { buffer, _ in\n            recognitionRequest.append(buffer)\n        }\n        \n        // Start audio engine\n        audioEngine.prepare()\n        do {\n            try audioEngine.start()\n        } catch {\n            errorMessage = \"Audio engine start failed: \\(error.localizedDescription)\"\n            return\n        }\n        \n        // Start recognition\n        recognitionTask = speechRecognizer.recognitionTask(with: recognitionRequest) { [weak self] result, error in\n            DispatchQueue.main.async {\n                if let result = result {\n                    self?.recognizedText = result.bestTranscription.formattedString\n                    self?.confidence = result.bestTranscription.segments.first?.confidence ?? 0.0\n                    \n                    if result.isFinal {\n                        self?.stopRecording()\n                    }\n                }\n                \n                if let error = error {\n                    self?.errorMessage = \"Recognition error: \\(error.localizedDescription)\"\n                    self?.stopRecording()\n                }\n            }\n        }\n        \n        isRecording = true\n        errorMessage = \"\"\n    }\n    \n    func stopRecording() {\n        audioEngine.stop()\n        audioEngine.inputNode.removeTap(onBus: 0)\n        \n        recognitionRequest?.endAudio()\n        recognitionRequest = nil\n        \n        recognitionTask?.cancel()\n        recognitionTask = nil\n        \n        isRecording = false\n        \n        // Reset audio session\n        do {\n            try AVAudioSession.sharedInstance().setCategory(.playAndRecord, mode: .default)\n        } catch {\n            print(\"Failed to reset audio session: \\(error)\")\n        }\n    }\n    \n    func reset() {\n        stopRecording()\n        recognizedText = \"\"\n        confidence = 0.0\n        errorMessage = \"\"\n    }\n    \n    // MARK: - Speech Analysis\n    func analyzePronunciation(target: String, spoken: String) -> PronunciationAnalysis {\n        let similarity = calculateSimilarity(target: target, spoken: spoken)\n        let accuracy = similarity * 100\n        \n        return PronunciationAnalysis(\n            targetText: target,\n            spokenText: spoken,\n            accuracy: accuracy,\n            confidence: confidence,\n            feedback: generateFeedback(accuracy: accuracy)\n        )\n    }\n    \n    private func calculateSimilarity(target: String, spoken: String) -> Float {\n        let targetLower = target.lowercased().trimmingCharacters(in: .whitespacesAndPunctuation)\n        let spokenLower = spoken.lowercased().trimmingCharacters(in: .whitespacesAndPunctuation)\n        \n        if targetLower == spokenLower {\n            return 1.0\n        }\n        \n        // Simple Levenshtein distance-based similarity\n        let distance = levenshteinDistance(targetLower, spokenLower)\n        let maxLength = max(targetLower.count, spokenLower.count)\n        \n        if maxLength == 0 {\n            return 1.0\n        }\n        \n        return max(0, 1.0 - Float(distance) / Float(maxLength))\n    }\n    \n    private func levenshteinDistance(_ str1: String, _ str2: String) -> Int {\n        let arr1 = Array(str1)\n        let arr2 = Array(str2)\n        \n        var matrix = Array(repeating: Array(repeating: 0, count: arr2.count + 1), count: arr1.count + 1)\n        \n        for i in 0...arr1.count {\n            matrix[i][0] = i\n        }\n        \n        for j in 0...arr2.count {\n            matrix[0][j] = j\n        }\n        \n        for i in 1...arr1.count {\n            for j in 1...arr2.count {\n                let cost = arr1[i-1] == arr2[j-1] ? 0 : 1\n                matrix[i][j] = min(\n                    matrix[i-1][j] + 1,      // deletion\n                    matrix[i][j-1] + 1,      // insertion\n                    matrix[i-1][j-1] + cost  // substitution\n                )\n            }\n        }\n        \n        return matrix[arr1.count][arr2.count]\n    }\n    \n    private func generateFeedback(accuracy: Float) -> String {\n        switch accuracy {\n        case 90...100:\n            return \"ÂÆåÁíß„Åß„ÅôÔºÅÁ¥†Êô¥„Çâ„Åó„ÅÑÁô∫Èü≥„Åß„Åô„Å≠„ÄÇ\"\n        case 80..<90:\n            return \"„Å®„Å¶„ÇÇËâØ„ÅÑÁô∫Èü≥„Åß„Åô„ÄÇÂ∞ë„ÅóÁ∑¥Áøí„Åô„Çå„Å∞„Åï„Çâ„Å´ËâØ„Åè„Å™„Çä„Åæ„Åô„ÄÇ\"\n        case 70..<80:\n            return \"ËâØ„ÅÑÁô∫Èü≥„Åß„Åô„ÄÇ„ÇÇ„ÅÜÂ∞ë„ÅóÁ∑¥Áøí„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ\"\n        case 60..<70:\n            return \"„Åæ„Åö„Åæ„Åö„ÅÆÁô∫Èü≥„Åß„Åô„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\"\n        default:\n            return \"„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÇÜ„Å£„Åè„ÇäÁô∫Èü≥„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\"\n        }\n    }\n}\n\n// MARK: - SFSpeechRecognizerDelegate\nextension SpeechRecognizer: SFSpeechRecognizerDelegate {\n    func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) {\n        DispatchQueue.main.async {\n            if !available {\n                self.errorMessage = \"Speech recognizer became unavailable\"\n                self.stopRecording()\n            }\n        }\n    }\n}\n\n// MARK: - Data Models\nstruct PronunciationAnalysis {\n    let targetText: String\n    let spokenText: String\n    let accuracy: Float\n    let confidence: Float\n    let feedback: String\n    \n    var grade: String {\n        switch accuracy {\n        case 90...100: return \"A\"\n        case 80..<90: return \"B\"\n        case 70..<80: return \"C\"\n        case 60..<70: return \"D\"\n        default: return \"F\"\n        }\n    }\n}","size_bytes":8358},"Sources/Services/TTSService.swift":{"content":"import AVFoundation\nimport SwiftUI\n\n@MainActor\nclass TTSService: NSObject, ObservableObject {\n    @Published var isSpeaking = false\n    @Published var errorMessage = \"\"\n    @Published var currentLanguage = \"en-US\"\n    @Published var speechRate: Float = 0.5\n    @Published var speechPitch: Float = 1.0\n    @Published var speechVolume: Float = 1.0\n    \n    private var synthesizer = AVSpeechSynthesizer()\n    private let supportedLanguages = [\"en-US\", \"ja-JP\", \"ko-KR\", \"fr-FR\", \"zh-CN\"]\n    \n    override init() {\n        super.init()\n        synthesizer.delegate = self\n        setupAudioSession()\n    }\n    \n    private func setupAudioSession() {\n        do {\n            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)\n            try AVAudioSession.sharedInstance().setActive(true)\n        } catch {\n            errorMessage = \"Audio session setup failed: \\(error.localizedDescription)\"\n        }\n    }\n    \n    func speak(_ text: String, language: String? = nil) {\n        guard !text.isEmpty else {\n            errorMessage = \"No text to speak\"\n            return\n        }\n        \n        // Stop any current speech\n        stop()\n        \n        let utterance = AVSpeechUtterance(string: text)\n        \n        // Set language\n        let lang = language ?? currentLanguage\n        if supportedLanguages.contains(lang) {\n            utterance.voice = AVSpeechSynthesisVoice(language: lang)\n        } else {\n            utterance.voice = AVSpeechSynthesisVoice(language: currentLanguage)\n        }\n        \n        // Configure speech parameters\n        utterance.rate = speechRate\n        utterance.pitchMultiplier = speechPitch\n        utterance.volume = speechVolume\n        \n        // Speak\n        synthesizer.speak(utterance)\n        errorMessage = \"\"\n    }\n    \n    func speakWithPhonetics(_ text: String, phonetics: String? = nil, language: String? = nil) {\n        // If phonetics are provided, use them for more accurate pronunciation\n        if let phonetics = phonetics, !phonetics.isEmpty {\n            speak(phonetics, language: language)\n        } else {\n            speak(text, language: language)\n        }\n    }\n    \n    func stop() {\n        if synthesizer.isSpeaking {\n            synthesizer.stopSpeaking(at: .immediate)\n        }\n    }\n    \n    func pause() {\n        if synthesizer.isSpeaking {\n            synthesizer.pauseSpeaking(at: .immediate)\n        }\n    }\n    \n    func resume() {\n        if synthesizer.isPaused {\n            synthesizer.continueSpeaking()\n        }\n    }\n    \n    func changeLanguage(to languageCode: String) {\n        guard supportedLanguages.contains(languageCode) else {\n            errorMessage = \"Unsupported language: \\(languageCode)\"\n            return\n        }\n        \n        currentLanguage = languageCode\n        errorMessage = \"\"\n    }\n    \n    func updateSpeechSettings(rate: Float, pitch: Float, volume: Float) {\n        speechRate = max(0.0, min(1.0, rate))\n        speechPitch = max(0.5, min(2.0, pitch))\n        speechVolume = max(0.0, min(1.0, volume))\n    }\n    \n    func getAvailableVoices(for language: String) -> [AVSpeechSynthesisVoice] {\n        return AVSpeechSynthesisVoice.speechVoices().filter { voice in\n            voice.language.hasPrefix(language.prefix(2).lowercased())\n        }\n    }\n    \n    func demonstratePronunciation(word: String, phonetics: String? = nil, language: String? = nil) {\n        let lang = language ?? currentLanguage\n        \n        // Speak the word slowly for demonstration\n        let originalRate = speechRate\n        speechRate = 0.3 // Slow down for demonstration\n        \n        speakWithPhonetics(word, phonetics: phonetics, language: lang)\n        \n        // Reset rate after a delay\n        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n            self.speechRate = originalRate\n        }\n    }\n}\n\n// MARK: - AVSpeechSynthesizerDelegate\nextension TTSService: AVSpeechSynthesizerDelegate {\n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance) {\n        isSpeaking = true\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {\n        isSpeaking = false\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didPause utterance: AVSpeechUtterance) {\n        // Handle pause if needed\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didContinue utterance: AVSpeechUtterance) {\n        // Handle resume if needed\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance) {\n        isSpeaking = false\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance) {\n        // Handle character range highlighting if needed for advanced features\n    }\n}\n\n// MARK: - Language Support Extensions\nextension TTSService {\n    var languageDisplayNames: [String: String] {\n        return [\n            \"en-US\": \"English (US)\",\n            \"ja-JP\": \"Êó•Êú¨Ë™û\",\n            \"ko-KR\": \"ÌïúÍµ≠Ïñ¥\",\n            \"fr-FR\": \"Fran√ßais\",\n            \"zh-CN\": \"‰∏≠Êñá (ÁÆÄ‰Ωì)\"\n        ]\n    }\n    \n    func getLanguageDisplayName(_ code: String) -> String {\n        return languageDisplayNames[code] ?? code\n    }\n}","size_bytes":5367},"demo/public/app.js":{"content":"// Notaps Unified Language Learning - Demo JavaScript\n\nclass NotapsApp {\n    constructor() {\n        this.currentTab = 'vocabulary'; // Start with vocabulary for TikTok-like experience\n        this.vocabulary = [];\n        this.progress = {};\n        this.currentWord = null;\n        this.currentVocabIndex = 0;\n        this.isTransitioning = false;\n        this.touchStartY = 0;\n        this.touchStartX = 0;\n        this.swipeThreshold = 50;\n        this.autoProgressTimer = null;\n        this.tabs = ['dashboard', 'vocabulary', 'pronunciation', 'progress', 'settings'];\n        this.streakCount = parseInt(localStorage.getItem('learningStreak') || '0');\n        this.sessionScore = 0;\n        this.wordsStudiedToday = parseInt(localStorage.getItem('wordsStudiedToday') || '0');\n        this.lastStudyDate = localStorage.getItem('lastStudyDate');\n        this.favorites = new Set(JSON.parse(localStorage.getItem('favoriteWords') || '[]'));\n        this.studyStats = JSON.parse(localStorage.getItem('studyStats') || '{}');\n        \n        // Language settings for focused vocabulary display\n        this.userNativeLanguage = 'ja'; // User's native language (Japanese)\n        this.learningLanguage = localStorage.getItem('learningLanguage') || 'en'; // User's selected study language\n        \n        // Vocabulary display modes\n        this.vocabularyMode = localStorage.getItem('vocabularyMode') || 'auto'; // auto, manual, swipe\n        this.autoProgressSpeed = parseInt(localStorage.getItem('autoProgressSpeed') || '3000'); // milliseconds\n        \n        // Expose app instance globally for onclick handlers\n        window.app = this;\n        \n        this.init();\n    }\n\n    async init() {\n        try {\n            console.log('Initializing NotapsApp...');\n            this.setupEventListeners();\n            this.setupSwipeGestures();\n            this.checkDailyReset();\n            \n            console.log('Loading progress and vocabulary...');\n            await this.loadProgress();\n            await this.loadVocabulary();\n            \n            console.log('Updating dashboard and progress...');\n            this.updateDashboard();\n            this.updateProgressTab();\n            \n            console.log('Switching to vocabulary tab...');\n            this.switchTab('vocabulary'); // Start with vocabulary mode\n            \n            console.log('Starting auto progression...');\n            this.startAutoProgression();\n            \n            console.log('Showing welcome message...');\n            this.showWelcomeMessage();\n            \n            console.log('App initialization complete!');\n        } catch (error) {\n            console.error('Error during app initialization:', error);\n        }\n    }\n\n    setupEventListeners() {\n        // Tab button click handlers\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                e.preventDefault();\n                const tabName = btn.getAttribute('data-tab');\n                if (tabName) {\n                    this.switchTab(tabName);\n                }\n            });\n        });\n\n        // Language setting handler\n        const learningLanguageSelect = document.getElementById('learning-language');\n        if (learningLanguageSelect) {\n            // Set current value\n            learningLanguageSelect.value = this.learningLanguage;\n            \n            learningLanguageSelect.addEventListener('change', (e) => {\n                this.learningLanguage = e.target.value;\n                localStorage.setItem('learningLanguage', this.learningLanguage);\n                \n                // Refresh vocabulary display\n                if (this.currentTab === 'vocabulary') {\n                    this.renderVocabularyTikTokStyle();\n                }\n                \n                this.showNotification('Â≠¶ÁøíË®ÄË™û„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü: ' + e.target.selectedOptions[0].text, 2000);\n            });\n        }\n\n        // Minimal tap-based interactions (mostly for settings)\n        const speechRate = document.getElementById('speech-rate');\n        const speechPitch = document.getElementById('speech-pitch');\n        \n        if (speechRate) {\n            speechRate.addEventListener('input', (e) => {\n                document.getElementById('rate-value').textContent = e.target.value + 'x';\n            });\n        }\n        \n        if (speechPitch) {\n            speechPitch.addEventListener('input', (e) => {\n                document.getElementById('pitch-value').textContent = e.target.value + 'x';\n            });\n        }\n\n        // Keyboard shortcuts for power users\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'ArrowUp') {\n                if (this.currentTab === 'vocabulary' && (this.vocabularyMode === 'manual' || this.vocabularyMode === 'swipe')) {\n                    this.previousVocabularyCard();\n                } else if (this.currentTab !== 'vocabulary') {\n                    this.previousContent();\n                }\n                // Do nothing for vocabulary + auto mode\n            }\n            if (e.key === 'ArrowDown') {\n                if (this.currentTab === 'vocabulary' && (this.vocabularyMode === 'manual' || this.vocabularyMode === 'swipe')) {\n                    this.nextVocabularyCard();\n                } else if (this.currentTab !== 'vocabulary') {\n                    this.nextContent();\n                }\n                // Do nothing for vocabulary + auto mode\n            }\n            if (e.key === 'ArrowLeft') this.previousTab();\n            if (e.key === 'ArrowRight') this.nextTab();\n            if (e.key === ' ') this.toggleAutoProgression();\n        });\n    }\n\n    setupSwipeGestures() {\n        const app = document.getElementById('app');\n        \n        // Touch start\n        app.addEventListener('touchstart', (e) => {\n            this.touchStartY = e.touches[0].clientY;\n            this.touchStartX = e.touches[0].clientX;\n            this.pauseAutoProgression();\n        }, { passive: true });\n        \n        // Touch move for real-time feedback\n        app.addEventListener('touchmove', (e) => {\n            if (this.isTransitioning) return;\n            \n            const currentY = e.touches[0].clientY;\n            const currentX = e.touches[0].clientX;\n            const deltaY = currentY - this.touchStartY;\n            const deltaX = currentX - this.touchStartX;\n            \n            // Show preview of next/previous content\n            if (Math.abs(deltaY) > Math.abs(deltaX) && this.currentTab === 'vocabulary' && this.vocabularyMode === 'swipe') {\n                // Only show vertical preview in vocabulary swipe mode\n                this.previewVerticalSwipe(deltaY);\n            } else if (this.currentTab !== 'dashboard') {\n                // Only show horizontal preview if not on dashboard\n                this.previewHorizontalSwipe(deltaX);\n            }\n        }, { passive: true });\n        \n        // Touch end\n        app.addEventListener('touchend', (e) => {\n            const touchEndY = e.changedTouches[0].clientY;\n            const touchEndX = e.changedTouches[0].clientX;\n            const deltaY = touchEndY - this.touchStartY;\n            const deltaX = touchEndX - this.touchStartX;\n            \n            this.resetPreview();\n            \n            // Determine swipe direction and execute\n            if (Math.abs(deltaY) > Math.abs(deltaX) && this.currentTab === 'vocabulary' && this.vocabularyMode === 'swipe') {\n                // Vertical swipe (only in vocabulary swipe mode)\n                if (Math.abs(deltaY) > this.swipeThreshold) {\n                    if (deltaY < 0) {\n                        this.nextVocabularyCard(); // Swipe up = next word\n                    } else {\n                        this.previousVocabularyCard(); // Swipe down = previous word\n                    }\n                }\n            } else if (Math.abs(deltaX) > Math.abs(deltaY) && this.currentTab !== 'dashboard') {\n                // Horizontal swipe for tab switching\n                if (Math.abs(deltaX) > this.swipeThreshold) {\n                    if (deltaX < 0) {\n                        this.previousTab(); // Swipe left = previous tab\n                    } else {\n                        this.nextTab(); // Swipe right = next tab\n                    }\n                }\n            } else {\n                // Horizontal swipe - disabled on dashboard to prevent accidental tab switching during scroll\n                if (this.currentTab !== 'dashboard' && Math.abs(deltaX) > this.swipeThreshold) {\n                    if (deltaX < 0) {\n                        this.previousTab(); // Swipe left = previous tab\n                    } else {\n                        this.nextTab(); // Swipe right = next tab\n                    }\n                }\n            }\n            \n            this.resumeAutoProgression();\n        }, { passive: true });\n        \n        // Mouse support for desktop testing\n        let isMouseDown = false;\n        \n        app.addEventListener('mousedown', (e) => {\n            isMouseDown = true;\n            this.touchStartY = e.clientY;\n            this.touchStartX = e.clientX;\n            this.pauseAutoProgression();\n        });\n        \n        app.addEventListener('mousemove', (e) => {\n            if (!isMouseDown || this.isTransitioning) return;\n            \n            const deltaY = e.clientY - this.touchStartY;\n            const deltaX = e.clientX - this.touchStartX;\n            \n            if (Math.abs(deltaY) > Math.abs(deltaX) && this.currentTab === 'vocabulary' && this.vocabularyMode === 'swipe') {\n                // Only show vertical preview in vocabulary swipe mode\n                this.previewVerticalSwipe(deltaY);\n            } else if (this.currentTab !== 'dashboard') {\n                // Only show horizontal preview if not on dashboard\n                this.previewHorizontalSwipe(deltaX);\n            }\n        });\n        \n        app.addEventListener('mouseup', (e) => {\n            if (!isMouseDown) return;\n            isMouseDown = false;\n            \n            const deltaY = e.clientY - this.touchStartY;\n            const deltaX = e.clientX - this.touchStartX;\n            \n            this.resetPreview();\n            \n            // Determine swipe direction and execute - aligned with touch behavior\n            if (Math.abs(deltaY) > Math.abs(deltaX) && this.currentTab === 'vocabulary' && this.vocabularyMode === 'swipe') {\n                // Vertical swipe (only in vocabulary swipe mode)\n                if (Math.abs(deltaY) > this.swipeThreshold) {\n                    if (deltaY < 0) {\n                        this.nextVocabularyCard(); // Swipe up = next word\n                    } else {\n                        this.previousVocabularyCard(); // Swipe down = previous word\n                    }\n                }\n            } else if (Math.abs(deltaX) > Math.abs(deltaY) && this.currentTab !== 'dashboard') {\n                // Horizontal swipe for tab switching\n                if (Math.abs(deltaX) > this.swipeThreshold) {\n                    if (deltaX < 0) {\n                        this.previousTab(); // Swipe left = previous tab\n                    } else {\n                        this.nextTab(); // Swipe right = next tab\n                    }\n                }\n            }\n            \n            this.resumeAutoProgression();\n        });\n    }\n\n    switchTab(tabName, direction = 'none') {\n        if (this.isTransitioning) return;\n        this.isTransitioning = true;\n        \n        const currentContent = document.getElementById(this.currentTab);\n        const nextContent = document.getElementById(tabName);\n        \n        // Add transition classes based on direction\n        if (direction === 'left') {\n            currentContent.classList.add('slide-out-right');\n            nextContent.classList.add('slide-in-left');\n        } else if (direction === 'right') {\n            currentContent.classList.add('slide-out-left');\n            nextContent.classList.add('slide-in-right');\n        }\n        \n        // Update active tab button with animation\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            btn.classList.remove('active');\n        });\n        const targetBtn = document.querySelector(`[data-tab=\"${tabName}\"]`);\n        if (targetBtn) {\n            targetBtn.classList.add('active');\n        }\n\n        // Update active tab content\n        setTimeout(() => {\n            document.querySelectorAll('.tab-content').forEach(content => {\n                content.classList.remove('active', 'slide-in-left', 'slide-in-right', 'slide-out-left', 'slide-out-right');\n            });\n            nextContent.classList.add('active');\n            \n            this.currentTab = tabName;\n            this.isTransitioning = false;\n            \n            // Load tab-specific content\n            if (tabName === 'vocabulary') {\n                this.renderVocabularyTikTokStyle();\n            } else if (tabName === 'pronunciation') {\n                this.loadRandomWord();\n            } else if (tabName === 'progress') {\n                this.updateProgressTab();\n            }\n        }, 300);\n    }\n\n    async loadProgress() {\n        try {\n            const response = await fetch('/api/progress');\n            this.progress = await response.json();\n        } catch (error) {\n            console.error('Failed to load progress:', error);\n            // Fallback to default progress\n            this.progress = {\n                currentLevel: 1,\n                completedLessons: 0,\n                pronunciationScore: 0,\n                vocabularyMastered: 0,\n                totalStudyTime: 0,\n                streakDays: 0\n            };\n        }\n    }\n\n    async loadVocabulary() {\n        try {\n            const language = 'all'; // Simplified for demo\n            const difficulty = 'all'; // Simplified for demo\n            \n            const response = await fetch(`/api/vocabulary?language=${language}&difficulty=${difficulty}&limit=10`);\n            if (!response.ok) {\n                throw new Error('Failed to fetch vocabulary');\n            }\n            this.vocabulary = await response.json();\n            \n            // Ensure we have vocabulary data\n            if (!this.vocabulary || this.vocabulary.length === 0) {\n                console.warn('No vocabulary data received');\n                this.vocabulary = []; // Fallback to empty array\n                return;\n            }\n            \n            // Reset index if needed\n            if (this.currentVocabIndex >= this.vocabulary.length) {\n                this.currentVocabIndex = 0;\n            }\n            \n            this.renderVocabulary();\n        } catch (error) {\n            console.error('Failed to load vocabulary:', error);\n            // Provide fallback vocabulary data\n            this.vocabulary = [\n                {\n                    id: 1,\n                    word: \"hello\",\n                    pronunciation: \"h…ôÀàlo ä\",\n                    definition: \"a greeting\",\n                    difficulty: \"beginner\",\n                    category: \"greetings\",\n                    translations: {\n                        ja: { word: \"„Åì„Çì„Å´„Å°„ÅØ\", pronunciation: \"konnichiwa\" }\n                    }\n                }\n            ];\n            this.renderVocabulary();\n        }\n    }\n\n    filterVocabulary() {\n        this.loadVocabulary();\n    }\n\n    renderVocabulary() {\n        // Legacy method, now use TikTok style\n        this.renderVocabularyTikTokStyle();\n    }\n    \n    renderVocabularyTikTokStyle() {\n        const container = document.getElementById('vocabulary-list');\n        if (!container || this.vocabulary.length === 0) return;\n\n        // Only clear and recreate if no card exists to prevent background flash\n        let card = container.querySelector('.tiktok-vocab-card');\n        if (!card) {\n            container.innerHTML = '';\n            container.className = 'tiktok-vocabulary-container';\n            card = document.createElement('div');\n            card.className = 'tiktok-vocab-card active';\n            container.appendChild(card);\n        }\n        \n        // Render current word in TikTok-like full screen format\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (!currentWord) return;\n        \n        // Initialize alternating display state if not set - always start with learning word\n        if (this.showingNativeLanguage === undefined) {\n            this.showingNativeLanguage = false;\n        }\n        \n        // Pre-calculate dynamic values to avoid template literal issues\n        const streakCount = this.streakCount || 0;\n        const wordsStudiedToday = this.wordsStudiedToday || 0;\n        const sessionScore = this.sessionScore || 0;\n        const wordId = currentWord.id || currentWord.word;\n        const isFavorite = this.favorites.has(wordId);\n        const favoriteIcon = isFavorite ? '‚ô•Ô∏è' : '‚ô°';\n        \n        // Generate content based on current display state\n        let mainContent = '';\n        if (this.showingNativeLanguage) {\n            // Show native language translation\n            const nativeTranslation = currentWord.translations[this.userNativeLanguage];\n            if (nativeTranslation) {\n                mainContent = `\n                    <div class=\"vocab-word-large native-word\">${nativeTranslation.word}</div>\n                    <div class=\"vocab-pronunciation-large\">/${nativeTranslation.pronunciation}/</div>\n                `;\n            }\n        } else {\n            // Show learning word\n            mainContent = `\n                <div class=\"vocab-word-large learning-word\">${currentWord.word}</div>\n                <div class=\"vocab-pronunciation-large\">/${currentWord.pronunciation}/</div>\n            `;\n        }\n        \n        // Remove progress dots for cleaner display\n        \n        // Mode-specific hint text\n        const getModeHint = () => {\n            switch(this.vocabularyMode) {\n                case 'auto': return 'üé¨ Ëá™Âãï„É¢„Éº„Éâ: Ëá™Âãï„ÅßÂçòË™û„ÅåÂàá„ÇäÊõø„Çè„Çä„Åæ„Åô';\n                case 'manual': return 'üëÜ „Éû„Éã„É•„Ç¢„É´„É¢„Éº„Éâ: „Éú„Çø„É≥„ÅßÂçòË™û„ÇíÂàá„ÇäÊõø„Åà';\n                case 'swipe': return 'üì± „Çπ„ÉØ„Ç§„Éó„É¢„Éº„Éâ: ‰∏ä‰∏ã„Çπ„ÉØ„Ç§„Éó„ÅßÂçòË™ûÂàá„ÇäÊõø„Åà';\n                default: return '‚Üë Ê¨°„ÅÆÂçòË™û | ‚Üì Ââç„ÅÆÂçòË™û | ‚Üê ‚Üí „Çø„ÉñÂàáÊõø';\n            }\n        };\n        \n        // Update card content without recreating the entire card element\n        card.innerHTML = `\n            <div class=\"vocabulary-mode-selector\">\n                <button class=\"mode-btn ${this.vocabularyMode === 'auto' ? 'active' : ''}\" onclick=\"app.setVocabularyMode('auto')\">\n                    üé¨ Ëá™Âãï\n                </button>\n                <button class=\"mode-btn ${this.vocabularyMode === 'manual' ? 'active' : ''}\" onclick=\"app.setVocabularyMode('manual')\">\n                    üëÜ ÊâãÂãï\n                </button>\n                <button class=\"mode-btn ${this.vocabularyMode === 'swipe' ? 'active' : ''}\" onclick=\"app.setVocabularyMode('swipe')\">\n                    üì± „Çπ„ÉØ„Ç§„Éó\n                </button>\n            </div>\n            \n            <div class=\"tiktok-vocab-content\">\n                ${mainContent}\n                \n                <div class=\"vocab-meta-large\">\n                    <span class=\"difficulty-badge-large difficulty-${currentWord.difficulty}\">\n                        ${this.getDifficultyDisplayName(currentWord.difficulty)}\n                    </span>\n                    <span class=\"category-badge\">${currentWord.category}</span>\n                </div>\n                \n                <!-- Simplified display - removed stats and progress dots -->\n            </div>\n            \n            <div class=\"side-actions\" id=\"side-actions\">\n                ${this.vocabularyMode === 'manual' ? `\n                    <button class=\"action-btn nav-btn\" onclick=\"app.previousVocabularyCard()\">\n                        ‚¨ÜÔ∏è\n                    </button>\n                    <button class=\"action-btn nav-btn\" onclick=\"app.nextVocabularyCard()\">\n                        ‚¨áÔ∏è\n                    </button>\n                ` : ''}\n                <button class=\"action-btn speak-btn\" onclick=\"app.speakCurrentWord()\">\n                    üîä\n                </button>\n                <button class=\"action-btn practice-btn\" onclick=\"app.practiceCurrentWord()\">\n                    üé§\n                </button>\n                <button class=\"action-btn favorite-btn\" onclick=\"app.toggleFavorite()\">\n                    ${favoriteIcon}\n                </button>\n                <button class=\"action-btn info-btn\" onclick=\"app.showWordInfo()\">\n                    ‚ÑπÔ∏è\n                </button>\n            </div>\n        `;\n        \n        // Auto-progression indicator removed for cleaner display\n        \n        // Setup auto-hide functionality for side actions\n        setTimeout(() => this.setupSideActionsAutoHide(), 100);\n    }\n    \n    setupSideActionsAutoHide() {\n        const sideActions = document.getElementById('side-actions');\n        if (!sideActions) return;\n        \n        // Clear any existing timer\n        if (this.sideActionsTimer) {\n            clearTimeout(this.sideActionsTimer);\n        }\n        \n        // Start auto-hide timer (5 seconds)\n        this.sideActionsTimer = setTimeout(() => {\n            sideActions.classList.add('auto-hidden');\n        }, 5000);\n        \n        // Add tap listener to vocabulary container to show side actions\n        const vocabContainer = document.querySelector('.tiktok-vocabulary-container');\n        if (vocabContainer) {\n            // Remove existing listener to prevent duplicates\n            vocabContainer.removeEventListener('click', this.showSideActionsHandler);\n            \n            // Store handler reference for removal\n            this.showSideActionsHandler = () => {\n                this.showSideActions();\n            };\n            \n            vocabContainer.addEventListener('click', this.showSideActionsHandler);\n        }\n        \n        // Reset timer on any user interaction\n        const resetTimer = () => {\n            this.showSideActions();\n        };\n        \n        // Add interaction listeners to reset timer\n        document.addEventListener('touchstart', resetTimer);\n        document.addEventListener('mousemove', resetTimer);\n        document.addEventListener('keydown', resetTimer);\n    }\n    \n    showSideActions() {\n        const sideActions = document.getElementById('side-actions');\n        if (!sideActions) return;\n        \n        sideActions.classList.remove('auto-hidden');\n        \n        // Reset auto-hide timer\n        if (this.sideActionsTimer) {\n            clearTimeout(this.sideActionsTimer);\n        }\n        \n        this.sideActionsTimer = setTimeout(() => {\n            sideActions.classList.add('auto-hidden');\n        }, 5000);\n    }\n\n    getDifficultyDisplayName(difficulty) {\n        const map = {\n            'beginner': 'ÂàùÁ¥ö',\n            'intermediate': '‰∏≠Á¥ö',\n            'advanced': '‰∏äÁ¥ö'\n        };\n        return map[difficulty] || difficulty;\n    }\n\n    updateDashboard() {\n        try {\n            // Update learning streak\n            const streakElement = document.getElementById('streak-days');\n            if (streakElement) {\n                streakElement.textContent = this.streakCount || 0;\n            }\n\n            // Update daily progress\n            const progressElement = document.getElementById('daily-progress');\n            if (progressElement) {\n                const dailyGoal = 10; // Daily vocabulary goal\n                progressElement.textContent = `${this.wordsStudiedToday}/${dailyGoal}`;\n            }\n\n            // Update social stats\n            const globalRankElement = document.getElementById('global-rank');\n            if (globalRankElement) {\n                // Simulate ranking based on progress\n                const rank = Math.max(1, 500 - (this.progress.vocabularyMastered || 0) * 5);\n                globalRankElement.textContent = `#${rank}`;\n            }\n\n            const friendsElement = document.getElementById('friends-count');\n            if (friendsElement) {\n                friendsElement.textContent = '12'; // Demo value\n            }\n\n            const weeklyScoreElement = document.getElementById('weekly-score');\n            if (weeklyScoreElement) {\n                const weeklyScore = (this.wordsStudiedToday * 50) + (this.streakCount * 10);\n                weeklyScoreElement.textContent = weeklyScore.toLocaleString();\n            }\n\n            // Generate language progress cards\n            this.generateLanguageCards();\n        } catch (error) {\n            console.warn('Some dashboard elements not found:', error);\n        }\n    }\n\n    updateProgressTab() {\n        // Update progress charts\n        const overallProgress = Math.min(100, (this.progress.completedLessons || 0) * 2);\n        const pronunciationProgress = this.progress.pronunciationScore || 0;\n        const vocabularyProgress = Math.min(100, (this.progress.vocabularyMastered || 0) * 2);\n\n        setTimeout(() => {\n            const overallBar = document.getElementById('overall-progress');\n            const pronunciationBar = document.getElementById('pronunciation-progress');\n            const vocabularyBar = document.getElementById('vocabulary-progress');\n\n            if (overallBar) {\n                overallBar.style.width = `${overallProgress}%`;\n                document.getElementById('overall-percentage').textContent = `${Math.round(overallProgress)}%`;\n            }\n\n            if (pronunciationBar) {\n                pronunciationBar.style.width = `${pronunciationProgress}%`;\n                document.getElementById('pronunciation-percentage').textContent = `${Math.round(pronunciationProgress)}%`;\n            }\n\n            if (vocabularyBar) {\n                vocabularyBar.style.width = `${vocabularyProgress}%`;\n                document.getElementById('vocabulary-percentage').textContent = `${Math.round(vocabularyProgress)}%`;\n            }\n        }, 100);\n    }\n\n    loadRandomWord() {\n        if (this.vocabulary.length > 0) {\n            const randomWord = this.vocabulary[Math.floor(Math.random() * this.vocabulary.length)];\n            this.currentWord = randomWord;\n            \n            const targetText = document.getElementById('target-text');\n            const targetPronunciation = document.getElementById('target-pronunciation');\n            \n            if (targetText) targetText.textContent = randomWord.word;\n            if (targetPronunciation) targetPronunciation.textContent = `/${randomWord.pronunciation}/`;\n        }\n    }\n    \n    // TikTok-style navigation methods\n    nextContent() {\n        if (this.isTransitioning) return;\n        \n        if (this.currentTab === 'vocabulary') {\n            // No vocabulary navigation in nextContent - only for non-vocabulary tabs\n            return;\n        } else if (this.currentTab !== 'dashboard') {\n            // For other tabs except dashboard, cycle through content if applicable\n            this.nextTab();\n        }\n        // Dashboard tab: do nothing to prevent accidental tab switching during scroll\n    }\n    \n    previousContent() {\n        if (this.isTransitioning) return;\n        \n        if (this.currentTab === 'vocabulary') {\n            // No vocabulary navigation in previousContent - only for non-vocabulary tabs\n            return;\n        } else if (this.currentTab !== 'dashboard') {\n            // For other tabs except dashboard, cycle through content\n            this.previousTab();\n        }\n        // Dashboard tab: do nothing to prevent accidental tab switching during scroll\n    }\n    \n    nextVocabularyCard() {\n        if (this.vocabulary.length === 0) return;\n        \n        // Correct alternating logic: word ‚Üí translation ‚Üí next word\n        if (!this.showingNativeLanguage) {\n            // Currently showing learning word, switch to native translation\n            this.showingNativeLanguage = true;\n        } else {\n            // Currently showing native translation, move to next word and show learning word\n            this.currentVocabIndex = (this.currentVocabIndex + 1) % this.vocabulary.length;\n            this.showingNativeLanguage = false;\n        }\n        \n        this.animateVocabularyTransition('up');\n        this.updateStudyStats();\n        this.showEncouragement();\n    }\n    \n    previousVocabularyCard() {\n        if (this.vocabulary.length === 0) return;\n        \n        // Correct alternating logic: translation ‚Üí word ‚Üí previous word  \n        if (this.showingNativeLanguage) {\n            // Currently showing native translation, switch to learning word\n            this.showingNativeLanguage = false;\n        } else {\n            // Currently showing learning word, move to previous word and show translation\n            this.currentVocabIndex = this.currentVocabIndex === 0 \n                ? this.vocabulary.length - 1 \n                : this.currentVocabIndex - 1;\n            this.showingNativeLanguage = true;\n        }\n        \n        this.animateVocabularyTransition('down');\n    }\n    \n    nextTab() {\n        const currentIndex = this.tabs.indexOf(this.currentTab);\n        const nextIndex = (currentIndex + 1) % this.tabs.length;\n        this.switchTab(this.tabs[nextIndex], 'left');\n    }\n    \n    previousTab() {\n        const currentIndex = this.tabs.indexOf(this.currentTab);\n        const prevIndex = currentIndex === 0 ? this.tabs.length - 1 : currentIndex - 1;\n        this.switchTab(this.tabs[prevIndex], 'right');\n    }\n    \n    animateVocabularyTransition(direction) {\n        this.isTransitioning = true;\n        const container = document.getElementById('vocabulary-list');\n        \n        // Use smooth fade transition for all modes to avoid jarring effects  \n        container.style.opacity = '0.2';\n        container.style.transition = 'opacity 0.15s ease';\n        \n        setTimeout(() => {\n            this.renderVocabularyTikTokStyle();\n            // Fade back in smoothly\n            container.style.opacity = '1';\n            setTimeout(() => {\n                this.isTransitioning = false;\n            }, 150);\n        }, 150);\n    }\n    \n    // Removed unused animation functions - using simple fade in animateVocabularyTransition\n    \n    previewVerticalSwipe(deltaY) {\n        const container = document.getElementById('vocabulary-list');\n        if (!container) return;\n        \n        const progress = Math.min(Math.abs(deltaY) / this.swipeThreshold, 1);\n        const translateY = deltaY * 0.3; // Dampened movement\n        \n        container.style.transform = `translateY(${translateY}px)`;\n        container.style.opacity = 1 - (progress * 0.2);\n    }\n    \n    previewHorizontalSwipe(deltaX) {\n        const currentContent = document.getElementById(this.currentTab);\n        if (!currentContent) return;\n        \n        const progress = Math.min(Math.abs(deltaX) / this.swipeThreshold, 1);\n        const translateX = deltaX * 0.3;\n        \n        currentContent.style.transform = `translateX(${translateX}px)`;\n        currentContent.style.opacity = 1 - (progress * 0.2);\n    }\n    \n    resetPreview() {\n        const container = document.getElementById('vocabulary-list');\n        const currentContent = document.getElementById(this.currentTab);\n        \n        if (container) {\n            container.style.transform = 'translateY(0)';\n            container.style.opacity = '1';\n        }\n        \n        if (currentContent) {\n            currentContent.style.transform = 'translateX(0)';\n            currentContent.style.opacity = '1';\n        }\n    }\n    \n    // Auto-progression features\n    startAutoProgression() {\n        // Clear any existing timer first\n        this.pauseAutoProgression();\n        \n        // Only start auto progression in auto mode\n        if (this.vocabularyMode === 'auto' && this.currentTab === 'vocabulary' && this.vocabulary && this.vocabulary.length > 0) {\n            this.autoProgressTimer = setInterval(() => {\n                this.nextVocabularyCard();\n            }, this.autoProgressSpeed);\n        }\n    }\n    \n    pauseAutoProgression() {\n        if (this.autoProgressTimer) {\n            clearInterval(this.autoProgressTimer);\n            this.autoProgressTimer = null;\n        }\n    }\n    \n    resumeAutoProgression() {\n        setTimeout(() => {\n            if (this.currentTab === 'vocabulary' && this.vocabularyMode === 'auto') {\n                this.startAutoProgression();\n            }\n        }, 2000); // Resume after 2 seconds\n    }\n    \n    setVocabularyMode(mode) {\n        if (['auto', 'manual', 'swipe'].includes(mode)) {\n            this.vocabularyMode = mode;\n            localStorage.setItem('vocabularyMode', mode);\n            \n            // Update auto progression based on mode\n            if (mode === 'auto') {\n                this.startAutoProgression();\n            } else {\n                this.pauseAutoProgression();\n            }\n            \n            // Update UI without full re-render to prevent background flash\n            if (this.currentTab === 'vocabulary') {\n                this.updateModeSelector();\n                this.updateSideActions();\n            }\n            \n            // Show notification below mode selector instead of toast\n            this.showModeChangeNotification(mode);\n        }\n    }\n    \n    toggleAutoProgression() {\n        if (this.autoProgressTimer) {\n            this.pauseAutoProgression();\n        } else {\n            this.startAutoProgression();\n        }\n    }\n    \n    // Utility methods for TikTok-style interactions\n    vibrate(pattern = 50) {\n        if (navigator.vibrate) {\n            navigator.vibrate(pattern);\n        }\n    }\n    \n    playSwipeSound(type = 'next') {\n        if (!('AudioContext' in window || 'webkitAudioContext' in window)) return;\n        \n        try {\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.setValueAtTime(type === 'back' ? 800 : 1200, audioContext.currentTime);\n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);\n            \n            oscillator.start(audioContext.currentTime);\n            oscillator.stop(audioContext.currentTime + 0.1);\n        } catch (error) {\n            // Silently fail if audio context creation fails\n        }\n    }\n    \n    playSuccessSound() {\n        if (!('AudioContext' in window || 'webkitAudioContext' in window)) return;\n        \n        try {\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            // Play a cheerful chord\n            oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5\n            oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1); // E5\n            oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2); // G5\n            \n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);\n            \n            oscillator.start(audioContext.currentTime);\n            oscillator.stop(audioContext.currentTime + 0.3);\n        } catch (error) {\n            // Silently fail if audio context creation fails\n        }\n    }\n    \n    showNotification(message, duration = 2000) {\n        // Remove existing notification\n        const existing = document.querySelector('.toast-notification');\n        if (existing) existing.remove();\n        \n        const notification = document.createElement('div');\n        notification.className = 'toast-notification';\n        notification.textContent = message;\n        \n        document.body.appendChild(notification);\n        \n        // Animate in\n        setTimeout(() => notification.classList.add('show'), 10);\n        \n        // Animate out\n        setTimeout(() => {\n            notification.classList.remove('show');\n            setTimeout(() => notification.remove(), 300);\n        }, duration);\n    }\n    \n    showModeChangeNotification(mode) {\n        // Remove existing mode notification\n        const existing = document.querySelector('.mode-change-notification');\n        if (existing) existing.remove();\n        \n        const modeNames = {\n            'auto': 'Ëá™Âãï',\n            'manual': 'ÊâãÂãï', \n            'swipe': '„Çπ„ÉØ„Ç§„Éó'\n        };\n        \n        const notification = document.createElement('div');\n        notification.className = 'mode-change-notification';\n        notification.textContent = `„É¢„Éº„Éâ„Çí${modeNames[mode]}„Å´Â§âÊõ¥„Åó„Åæ„Åó„Åü`;\n        \n        // Insert after mode selector\n        const modeSelector = document.querySelector('.vocabulary-mode-selector');\n        if (modeSelector && modeSelector.parentNode) {\n            modeSelector.parentNode.insertBefore(notification, modeSelector.nextSibling);\n        }\n        \n        // Animate in\n        setTimeout(() => notification.classList.add('show'), 10);\n        \n        // Animate out after 2 seconds\n        setTimeout(() => {\n            notification.classList.remove('show');\n            setTimeout(() => {\n                if (notification.parentNode) {\n                    notification.remove();\n                }\n            }, 300);\n        }, 2000);\n    }\n    \n    updateModeSelector() {\n        // Update mode selector buttons without full re-render\n        const buttons = document.querySelectorAll('.mode-btn');\n        buttons.forEach(btn => {\n            btn.classList.remove('active');\n            if ((btn.textContent.includes('Ëá™Âãï') && this.vocabularyMode === 'auto') ||\n                (btn.textContent.includes('ÊâãÂãï') && this.vocabularyMode === 'manual') ||\n                (btn.textContent.includes('„Çπ„ÉØ„Ç§„Éó') && this.vocabularyMode === 'swipe')) {\n                btn.classList.add('active');\n            }\n        });\n    }\n    \n    updateSideActions() {\n        // Update side actions without full re-render\n        const sideActions = document.getElementById('side-actions');\n        if (!sideActions) return;\n        \n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (!currentWord) return;\n        \n        const wordId = currentWord.id || currentWord.word;\n        const isFavorite = this.favorites.has(wordId);\n        const favoriteIcon = isFavorite ? '‚ô•Ô∏è' : '‚ô°';\n        \n        sideActions.innerHTML = `\n            ${this.vocabularyMode === 'manual' ? `\n                <button class=\"action-btn nav-btn\" onclick=\"app.previousVocabularyCard()\">\n                    ‚¨ÜÔ∏è\n                </button>\n                <button class=\"action-btn nav-btn\" onclick=\"app.nextVocabularyCard()\">\n                    ‚¨áÔ∏è\n                </button>\n            ` : ''}\n            <button class=\"action-btn speak-btn\" onclick=\"app.speakCurrentWord()\">\n                üîä\n            </button>\n            <button class=\"action-btn practice-btn\" onclick=\"app.practiceCurrentWord()\">\n                üé§\n            </button>\n            <button class=\"action-btn favorite-btn\" onclick=\"app.toggleFavorite()\">\n                ${favoriteIcon}\n            </button>\n            <button class=\"action-btn info-btn\" onclick=\"app.showWordInfo()\">\n                ‚ÑπÔ∏è\n            </button>\n        `;\n        \n        // Preserve auto-hide functionality for side actions\n        setTimeout(() => this.setupSideActionsAutoHide(), 50);\n    }\n    \n    showEncouragement() {\n        // Disabled motivational messages to maintain concentration during learning\n        // ÈõÜ‰∏≠Âäõ„Çí‰øù„Å§„Åü„ÇÅÂä±„Åæ„Åó„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÁÑ°ÂäπÂåñ\n        return;\n    }\n    \n    updateStudyStats() {\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (!currentWord) return;\n        \n        const wordKey = currentWord.word;\n        this.studyStats[wordKey] = this.studyStats[wordKey] || { views: 0, practiced: 0 };\n        this.studyStats[wordKey].views += 1;\n        \n        this.wordsStudiedToday += 1;\n        this.sessionScore += 10;\n        \n        // Save to localStorage\n        localStorage.setItem('studyStats', JSON.stringify(this.studyStats));\n        localStorage.setItem('wordsStudiedToday', this.wordsStudiedToday.toString());\n        localStorage.setItem('lastStudyDate', new Date().toDateString());\n        \n        // Update streak\n        this.updateStreak();\n        \n        // Achievement check\n        this.checkAchievements();\n    }\n    \n    updateStreak() {\n        const today = new Date().toDateString();\n        const lastDate = this.lastStudyDate;\n        \n        if (!lastDate || lastDate !== today) {\n            if (this.isConsecutiveDay(lastDate)) {\n                this.streakCount += 1;\n            } else {\n                this.streakCount = 1;\n            }\n            localStorage.setItem('learningStreak', this.streakCount.toString());\n        }\n    }\n    \n    isConsecutiveDay(lastDate) {\n        if (!lastDate) return false;\n        \n        const last = new Date(lastDate);\n        const today = new Date();\n        const diffTime = today.getTime() - last.getTime();\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        \n        return diffDays === 1;\n    }\n    \n    checkDailyReset() {\n        const today = new Date().toDateString();\n        const lastDate = this.lastStudyDate;\n        \n        if (lastDate !== today) {\n            this.wordsStudiedToday = 0;\n            this.sessionScore = 0;\n            localStorage.setItem('wordsStudiedToday', '0');\n        }\n    }\n    \n    checkAchievements() {\n        // Disabled achievement notifications to maintain focus during learning\n        // Â≠¶Áøí‰∏≠„ÅÆÈõÜ‰∏≠Âäõ„Çí‰øù„Å§„Åü„ÇÅÈÅîÊàêÈÄöÁü•„ÇíÁÑ°ÂäπÂåñ\n        if (this.wordsStudiedToday === 10) {\n            // this.showNotification('üèÜ ‰ªäÊó•„ÅÆÁõÆÊ®ôÈÅîÊàêÔºÅ', 3000);\n            this.playSuccessSound();\n            this.vibrate([100, 50, 100]);\n        }\n        \n        if (this.streakCount === 7) {\n            // this.showNotification('üî• 7Êó•ÈÄ£Á∂öÈÅîÊàêÔºÅ', 3000);\n            this.playSuccessSound();\n        }\n        \n        if (this.favorites.size === 5) {\n            // this.showNotification('‚ô•Ô∏è „ÅäÊ∞ó„Å´ÂÖ•„Çä5ÂÄãÈÅîÊàêÔºÅ', 3000);\n        }\n    }\n    \n    updateFavoriteButton() {\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (!currentWord) return;\n        \n        const favoriteBtn = document.querySelector('.favorite-btn');\n        if (favoriteBtn) {\n            const wordId = currentWord.id || currentWord.word;\n            favoriteBtn.textContent = this.favorites.has(wordId) ? '‚ô•Ô∏è' : '‚ô°';\n        }\n    }\n    \n    showWelcomeMessage() {\n        // Disabled welcome messages to avoid interrupting concentration\n        // ÈõÜ‰∏≠Âäõ„ÇíÂ¶®„Åí„Å™„ÅÑ„Çà„ÅÜ„Ç¶„Çß„É´„Ç´„É†„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÁÑ°ÂäπÂåñ\n        // setTimeout(() => {\n        //     if (this.streakCount > 0) {\n        //         this.showNotification(`üî• ${this.streakCount}Êó•ÈÄ£Á∂ö‰∏≠ÔºÅÁ∂ôÁ∂ö„Åó„Åæ„Åó„Çá„ÅÜÔºÅ`, 3000);\n        //     } else {\n        //         this.showNotification('üéÜ Â≠¶Áøí„ÇíÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜÔºÅ', 2000);\n        //     }\n        // }, 1000);\n    }\n    \n    getLanguageFlag(langCode) {\n        // Remove flags for native language (Japanese) as requested\n        if (langCode === this.userNativeLanguage) {\n            return '';\n        }\n        const flags = {\n            'en': 'üá∫üá∏',\n            'ja': '',  // No flag for Japanese\n            'ko': 'üá∞üá∑',\n            'fr': 'üá´üá∑',\n            'zh': 'üá®üá≥'\n        };\n        return flags[langCode] || 'üåê';\n    }\n    \n    speakCurrentWord() {\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if ('speechSynthesis' in window && currentWord) {\n            const utterance = new SpeechSynthesisUtterance(currentWord.word);\n            utterance.rate = 0.8;\n            utterance.pitch = 1.0;\n            speechSynthesis.speak(utterance);\n            this.vibrate();\n        }\n    }\n    \n    practiceCurrentWord() {\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (currentWord) {\n            this.currentWord = currentWord;\n            this.switchTab('pronunciation');\n            setTimeout(() => {\n                const targetText = document.getElementById('target-text');\n                const targetPronunciation = document.getElementById('target-pronunciation');\n                \n                if (targetText) targetText.textContent = currentWord.word;\n                if (targetPronunciation) targetPronunciation.textContent = `/${currentWord.pronunciation}/`;\n            }, 300);\n        }\n    }\n    \n    toggleFavorite() {\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (!currentWord) return;\n        \n        const wordId = currentWord.id || currentWord.word;\n        \n        if (this.favorites.has(wordId)) {\n            this.favorites.delete(wordId);\n            this.showNotification('‚ô° „ÅäÊ∞ó„Å´ÂÖ•„Çä„Åã„ÇâÂâäÈô§„Åó„Åæ„Åó„Åü');\n        } else {\n            this.favorites.add(wordId);\n            this.showNotification('‚ô•Ô∏è „ÅäÊ∞ó„Å´ÂÖ•„Çä„Å´ËøΩÂä†„Åó„Åæ„Åó„ÅüÔºÅ');\n            this.playSuccessSound();\n        }\n        \n        localStorage.setItem('favoriteWords', JSON.stringify([...this.favorites]));\n        this.updateFavoriteButton();\n        this.vibrate();\n    }\n    \n    showWordInfo() {\n        const currentWord = this.vocabulary[this.currentVocabIndex];\n        if (!currentWord) return;\n        \n        const stats = this.studyStats[currentWord.word] || { views: 0, practiced: 0 };\n        \n        const info = `\n        üìä Â≠¶ÁøíÁµ±Ë®à:\n        ‚Ä¢ Èñ≤Ë¶ßÂõûÊï∞: ${stats.views}Âõû\n        ‚Ä¢ Á∑¥ÁøíÂõûÊï∞: ${stats.practiced}Âõû\n        ‚Ä¢ „Ç´„ÉÜ„Ç¥„É™: ${currentWord.category}\n        ‚Ä¢ Èõ£ÊòìÂ∫¶: ${this.getDifficultyDisplayName(currentWord.difficulty)}\n        `;\n        \n        this.showNotification(info, 3000);\n        this.vibrate();\n    }\n\n    practiceWord(word, pronunciation) {\n        this.currentWord = { word, pronunciation };\n        this.switchTab('pronunciation');\n        setTimeout(() => {\n            const targetText = document.getElementById('target-text');\n            const targetPronunciation = document.getElementById('target-pronunciation');\n            \n            if (targetText) targetText.textContent = word;\n            if (targetPronunciation) targetPronunciation.textContent = `/${pronunciation}/`;\n        }, 300);\n    }\n\n    playTargetAudio() {\n        if ('speechSynthesis' in window && this.currentWord) {\n            const utterance = new SpeechSynthesisUtterance(this.currentWord.word);\n            utterance.rate = 0.8;\n            utterance.pitch = 1.0;\n            speechSynthesis.speak(utterance);\n        } else {\n            alert('Èü≥Â£∞ÂêàÊàê„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ');\n        }\n    }\n\n    async analyzePronunciation() {\n        const targetText = document.getElementById('target-text').textContent;\n        const spokenText = document.getElementById('spoken-input').value.trim();\n\n        if (!spokenText) {\n            alert('Áô∫Èü≥ÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');\n            return;\n        }\n\n        try {\n            const response = await fetch('/api/practice/pronunciation', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    targetText,\n                    spokenText\n                })\n            });\n\n            const analysis = await response.json();\n            this.displayPronunciationResult(analysis);\n            \n            // Update progress\n            await this.updateLearningProgress(analysis.accuracy);\n            \n        } catch (error) {\n            console.error('Pronunciation analysis failed:', error);\n            alert('Áô∫Èü≥ÂàÜÊûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');\n        }\n    }\n\n    displayPronunciationResult(analysis) {\n        const resultArea = document.getElementById('pronunciation-result');\n        resultArea.style.display = 'block';\n\n        document.getElementById('accuracy-score').textContent = `${analysis.accuracy}%`;\n        document.getElementById('pronunciation-grade').textContent = analysis.grade;\n        document.getElementById('pronunciation-feedback').textContent = analysis.feedback;\n\n        // Update grade color\n        const gradeElement = document.getElementById('pronunciation-grade');\n        gradeElement.className = 'grade';\n        if (analysis.accuracy >= 90) {\n            gradeElement.style.background = '#28a745';\n        } else if (analysis.accuracy >= 80) {\n            gradeElement.style.background = '#17a2b8';\n        } else if (analysis.accuracy >= 70) {\n            gradeElement.style.background = '#ffc107';\n        } else {\n            gradeElement.style.background = '#dc3545';\n        }\n\n        // Scroll to result\n        resultArea.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    async updateLearningProgress(score) {\n        try {\n            const response = await fetch('/api/progress/update', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    lesson: 'pronunciation',\n                    score: score,\n                    timeSpent: 5\n                })\n            });\n\n            this.progress = await response.json();\n            this.updateDashboard();\n        } catch (error) {\n            console.error('Failed to update progress:', error);\n        }\n    }\n\n    startReview() {\n        this.switchTab('vocabulary');\n        // Could implement specific review logic here\n    }\n\n    startTest() {\n        alert('„ÉÜ„Çπ„ÉàÊ©üËÉΩ„ÅØÈñãÁô∫‰∏≠„Åß„Åô„ÄÇ');\n        // Could implement test functionality here\n    }\n\n    // New Dashboard Functions for Multilingual LTV Optimization\n\n    generateLanguageCards() {\n        const languageCardsContainer = document.getElementById('language-cards');\n        if (!languageCardsContainer) return;\n\n        // Demo languages with progress simulation\n        const activeLanguages = [\n            {\n                code: 'en',\n                name: 'English',\n                flag: 'üá∫üá∏',\n                progress: Math.min(100, (this.progress.vocabularyMastered || 0) * 4),\n                level: 'Intermediate',\n                wordsLearned: this.progress.vocabularyMastered || 0\n            },\n            {\n                code: 'ja',\n                name: 'Êó•Êú¨Ë™û',\n                flag: 'üáØüáµ',\n                progress: 75,\n                level: 'Advanced',\n                wordsLearned: 450\n            },\n            {\n                code: 'ko',\n                name: 'ÌïúÍµ≠Ïñ¥',\n                flag: 'üá∞üá∑',\n                progress: 30,\n                level: 'Beginner',\n                wordsLearned: 120\n            }\n        ];\n\n        languageCardsContainer.innerHTML = activeLanguages.map(lang => `\n            <div class=\"language-card\" onclick=\"app.selectLanguage('${lang.code}')\">\n                <div class=\"language-flag\">${lang.flag}</div>\n                <div class=\"language-name\">${lang.name}</div>\n                <div class=\"language-progress\">${lang.progress}% ÂÆå‰∫Ü</div>\n                <div class=\"language-level\">${lang.level}</div>\n            </div>\n        `).join('');\n    }\n\n    selectLanguage(languageCode) {\n        console.log(`Switching to language: ${languageCode}`);\n        // Switch to vocabulary learning for selected language\n        this.currentLanguage = languageCode;\n        this.switchTab('vocabulary');\n        this.showToast(`${languageCode.toUpperCase()} Â≠¶Áøí„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà„Åæ„Åó„Åü`);\n    }\n\n    showLanguageDetails() {\n        alert('Ë®ÄË™ûË©≥Á¥∞Ê©üËÉΩ„ÇíÈñãÁô∫‰∏≠„Åß„Åô„ÄÇ\\n\\n‰ªäÂæå„ÅÆÊ©üËÉΩ:\\n‚Ä¢ Ë©≥Á¥∞„Å™ÈÄ≤Êçó„Ç∞„É©„Éï\\n‚Ä¢ ÁøíÂæó„Çπ„Ç≠„É´ÂàÜÊûê\\n‚Ä¢ Â≠¶ÁøíÁõÆÊ®ôË®≠ÂÆö\\n‚Ä¢ „Ç´„Çπ„Çø„É†Âæ©Áøí„Éó„É©„É≥');\n    }\n\n    showAddLanguage() {\n        const availableLanguages = [\n            'üá´üá∑ French (Fran√ßais)',\n            'üá®üá≥ Chinese (‰∏≠Êñá)',\n            'üá©üá™ German (Deutsch)',\n            'üá™üá∏ Spanish (Espa√±ol)',\n            'üáÆüáπ Italian (Italiano)',\n            'üá∑üá∫ Russian (–†—É—Å—Å–∫–∏–π)',\n            'üáµüáπ Portuguese (Portugu√™s)',\n            'üá≥üá± Dutch (Nederlands)'\n        ];\n        \n        const languageList = availableLanguages.join('\\n‚Ä¢ ');\n        \n        alert(`Êñ∞„Åó„ÅÑË®ÄË™û„ÇíËøΩÂä†\\n\\nÂà©Áî®ÂèØËÉΩ„Å™Ë®ÄË™û:\\n‚Ä¢ ${languageList}\\n\\n‚ú® ÂêÑË®ÄË™û„ÅßÊï∞ÂçÉ„ÅÆÂçòË™û„Å®Ë°®Áèæ„ÇíÂ≠¶Áøí\\nüìà AI„Éë„Éº„ÇΩ„Éä„É©„Ç§„Ç∫Â≠¶Áøí\\nüéØ ÁõÆÊ®ôË®≠ÂÆö„Å®ÈÄ≤ÊçóËøΩË∑°\\n\\nÁÑ°Êñô„Åß‰ªä„Åô„ÅêÈñãÂßã„Åß„Åç„Åæ„ÅôÔºÅ`);\n    }\n\n    showPremiumFeatures() {\n        alert(`üåü Notaps Premium\\n\\n‰ª•‰∏ã„ÅÆÊ©üËÉΩ„ÅßÂ≠¶ÁøíÂäπÁéá„ÇíÊúÄÂ§ßÂåñ:\\n\\nüìä Ë©≥Á¥∞ÂàÜÊûê„É¨„Éù„Éº„Éà\\n‚Ä¢ ÁøíÂæóÈÄüÂ∫¶ÂàÜÊûê\\n‚Ä¢ Âº±ÁÇπÁâπÂÆö\\n‚Ä¢ Â≠¶Áøí„Éë„Çø„Éº„É≥ÊúÄÈÅ©Âåñ\\n\\nüéØ ÂÄã‰∫∫Â∞ÇÁî®Â≠¶Áøí„Éó„É©„É≥\\n‚Ä¢ AIÂ≠¶Áøí„Ç≥„Éº„ÉÅ\\n‚Ä¢ „Ç´„Çπ„Çø„É†ÁõÆÊ®ôË®≠ÂÆö\\n‚Ä¢ ÈÅ©ÂøúÂûã„Ç´„É™„Ç≠„É•„É©„É†\\n\\nüîÑ ÁÑ°Âà∂ÈôêÂæ©Áøí„É¢„Éº„Éâ\\n‚Ä¢ „Çπ„Éû„Éº„ÉàÂæ©Áøí„Ç∑„Çπ„ÉÜ„É†\\n‚Ä¢ ÂøòÂç¥Êõ≤Á∑öÊúÄÈÅ©Âåñ\\n‚Ä¢ „Ç´„Çπ„Çø„É†Âæ©ÁøíÈñìÈöî\\n\\nüé§ AIÁô∫Èü≥„Ç≥„Éº„ÉÅ\\n‚Ä¢ „É™„Ç¢„É´„Çø„Ç§„É†Áô∫Èü≥ÂàÜÊûê\\n‚Ä¢ „Ç¢„ÇØ„Çª„É≥„ÉàÊîπÂñÑ\\n‚Ä¢ „Éç„Ç§„ÉÜ„Ç£„ÉñÊØîËºÉ\\n\\nüíé 7Êó•ÈñìÁÑ°Êñô‰ΩìÈ®ìÈñãÂßã`);\n    }\n\n    showLeaderboard() {\n        const mockLeaderboard = [\n            'ü•á Áî∞‰∏≠Â§™ÈÉé - 2,847 pts',\n            'ü•à Smith John - 2,693 pts',\n            'ü•â ÍπÄÎØºÏàò - 2,541 pts',\n            '4Ô∏è‚É£ „ÅÇ„Å™„Åü - 1,247 pts',\n            '5Ô∏è‚É£ Marie Dupont - 1,156 pts',\n            '6Ô∏è‚É£ Chen Wei - 1,089 pts',\n            '7Ô∏è‚É£ Anna Schmidt - 987 pts'\n        ];\n\n        alert(`üèÜ ‰ªäÈÄ±„ÅÆ„É©„É≥„Ç≠„É≥„Ç∞\\n\\n${mockLeaderboard.join('\\n')}\\n\\nüî• ÈÄ£Á∂öÂ≠¶Áøí„Åß„Éù„Ç§„É≥„Éà„Ç¢„ÉÉ„ÉóÔºÅ\\nüìö Êñ∞„Åó„ÅÑË®ÄË™û„Åß„Éú„Éº„Éä„Çπ„Éù„Ç§„É≥„ÉàÁç≤Âæó\\nüë• ÂèãÈÅî„ÇíÊãõÂæÖ„Åó„Å¶„É©„É≥„Ç≠„É≥„Ç∞‰∏äÊòá`);\n    }\n\n    showToast(message, duration = 3000) {\n        // Create toast notification\n        const toast = document.createElement('div');\n        toast.className = 'toast-notification';\n        toast.textContent = message;\n        toast.style.cssText = `\n            position: fixed;\n            top: 80px;\n            left: 50%;\n            transform: translateX(-50%);\n            background: rgba(0,0,0,0.8);\n            color: white;\n            padding: 12px 20px;\n            border-radius: 25px;\n            font-size: 14px;\n            z-index: 1000;\n            opacity: 0;\n            transition: opacity 0.3s ease;\n        `;\n        \n        document.body.appendChild(toast);\n        \n        // Animate in\n        setTimeout(() => {\n            toast.style.opacity = '1';\n        }, 100);\n        \n        // Remove after duration\n        setTimeout(() => {\n            toast.style.opacity = '0';\n            setTimeout(() => {\n                if (toast.parentNode) {\n                    toast.parentNode.removeChild(toast);\n                }\n            }, 300);\n        }, duration);\n    }\n}\n\n// Initialize app when DOM is loaded\nlet app;\n\n// Global functions for HTML onclick events (with safety checks)\nfunction switchTab(tabName) {\n    if (app && app.switchTab) {\n        app.switchTab(tabName);\n    } else {\n        console.log('App not ready yet, retrying...');\n        setTimeout(() => switchTab(tabName), 100);\n    }\n}\n\nfunction playTargetAudio() {\n    if (app && app.playTargetAudio) {\n        app.playTargetAudio();\n    }\n}\n\nfunction analyzePronunciation() {\n    if (app && app.analyzePronunciation) {\n        app.analyzePronunciation();\n    }\n}\n\nfunction startReview() {\n    if (app && app.startReview) {\n        app.startReview();\n    }\n}\n\nfunction startTest() {\n    if (app && app.startTest) {\n        app.startTest();\n    }\n}\n\n// Initialize app when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log('DOM loaded, initializing app...');\n    try {\n        app = new NotapsApp();\n        console.log('App initialized successfully');\n    } catch (error) {\n        console.error('Failed to initialize app:', error);\n    }\n});\n\n// Service Worker registration disabled for demo\n// if ('serviceWorker' in navigator) {\n//     window.addEventListener('load', () => {\n//         navigator.serviceWorker.register('/sw.js')\n//             .then(registration => {\n//                 console.log('SW registered: ', registration);\n//             })\n//             .catch(registrationError => {\n//                 console.log('SW registration failed: ', registrationError);\n//             });\n//     });\n// }","size_bytes":57643},"demo/public/styles.css":{"content":"/* Notaps Unified Language Learning - Demo Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    color: #333;\n}\n\n#app {\n    max-width: 420px;\n    margin: 0 auto;\n    background: white;\n    min-height: 100vh;\n    box-shadow: 0 0 30px rgba(0,0,0,0.1);\n    position: relative;\n    overflow: hidden;\n    touch-action: pan-y;\n}\n\n/* Prevent text selection during swipes */\n#app * {\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n/* Allow text selection for input fields */\ninput, textarea, [contenteditable] {\n    -webkit-user-select: text !important;\n    -moz-user-select: text !important;\n    -ms-user-select: text !important;\n    user-select: text !important;\n}\n\n.app-header {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 20px;\n    text-align: center;\n}\n\n.app-header h1 {\n    font-size: 24px;\n    font-weight: 600;\n    margin-bottom: 5px;\n}\n\n.subtitle {\n    font-size: 14px;\n    opacity: 0.9;\n}\n\n.tab-nav {\n    display: flex;\n    background: #f8f9fa;\n    border-bottom: 1px solid #e9ecef;\n    position: relative;\n    overflow: hidden;\n}\n\n.tab-nav::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(90deg, \n        rgba(102, 126, 234, 0.1) 0%, \n        rgba(118, 75, 162, 0.1) 100%);\n    opacity: 0;\n    transition: opacity 0.3s ease;\n}\n\n.tab-nav:hover::before {\n    opacity: 1;\n}\n\n.tab-btn {\n    flex: 1;\n    padding: 12px 8px;\n    border: none;\n    background: transparent;\n    font-size: 11px;\n    cursor: pointer;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    position: relative;\n    z-index: 1;\n}\n\n.tab-btn:hover {\n    background: rgba(102, 126, 234, 0.1);\n}\n\n.tab-btn.active {\n    background: white;\n    color: #667eea;\n    font-weight: 600;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);\n}\n\n.tab-btn.active::after {\n    content: '';\n    position: absolute;\n    bottom: -1px;\n    left: 0;\n    right: 0;\n    height: 3px;\n    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);\n    border-radius: 3px 3px 0 0;\n}\n\n.tab-content {\n    display: none;\n    padding: 20px;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    position: relative;\n    overflow: hidden;\n}\n\n.tab-content.active {\n    display: block;\n}\n\n/* Tab transition animations */\n.slide-in-left {\n    transform: translateX(-100%);\n    animation: slideInLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;\n}\n\n.slide-in-right {\n    transform: translateX(100%);\n    animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;\n}\n\n.slide-out-left {\n    animation: slideOutLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;\n}\n\n.slide-out-right {\n    animation: slideOutRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;\n}\n\n@keyframes slideInLeft {\n    from { transform: translateX(-100%); }\n    to { transform: translateX(0); }\n}\n\n@keyframes slideInRight {\n    from { transform: translateX(100%); }\n    to { transform: translateX(0); }\n}\n\n@keyframes slideOutLeft {\n    from { transform: translateX(0); }\n    to { transform: translateX(-100%); }\n}\n\n@keyframes slideOutRight {\n    from { transform: translateX(0); }\n    to { transform: translateX(100%); }\n}\n\n.welcome-section {\n    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);\n    color: white;\n    padding: 20px;\n    border-radius: 12px;\n    margin-bottom: 20px;\n}\n\n.welcome-section h2 {\n    font-size: 20px;\n    margin-bottom: 8px;\n}\n\n.stats-grid {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 15px;\n    margin-bottom: 25px;\n}\n\n.stat-card {\n    background: #f8f9fa;\n    padding: 15px;\n    border-radius: 8px;\n    text-align: center;\n}\n\n.stat-value {\n    font-size: 24px;\n    font-weight: bold;\n    color: #667eea;\n    margin-bottom: 5px;\n}\n\n.stat-label {\n    font-size: 12px;\n    color: #6c757d;\n}\n\n.quick-actions h3 {\n    margin-bottom: 15px;\n    color: #333;\n}\n\n.action-grid {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 15px;\n}\n\n.action-card {\n    background: #f8f9fa;\n    padding: 15px;\n    border-radius: 12px;\n    text-align: center;\n    cursor: pointer;\n    transition: transform 0.2s ease;\n}\n\n.action-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n}\n\n.action-icon {\n    font-size: 24px;\n    margin-bottom: 8px;\n}\n\n.action-title {\n    font-weight: 600;\n    margin-bottom: 4px;\n}\n\n.action-subtitle {\n    font-size: 12px;\n    color: #6c757d;\n}\n\n.section-header {\n    margin-bottom: 20px;\n}\n\n.section-header h2 {\n    color: #333;\n    margin-bottom: 8px;\n}\n\n.filters {\n    display: flex;\n    gap: 10px;\n    margin-top: 10px;\n}\n\n.filters select {\n    padding: 8px 12px;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    font-size: 14px;\n}\n\n.vocabulary-list {\n    display: grid;\n    gap: 15px;\n}\n\n/* TikTok-style vocabulary container */\n.tiktok-vocabulary-container {\n    position: relative;\n    height: calc(100vh - 200px);\n    overflow: hidden;\n    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.tiktok-vocab-card {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    border-radius: 20px;\n    padding: 30px 20px;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    color: white;\n    box-shadow: 0 8px 32px rgba(0,0,0,0.2);\n    user-select: none;\n}\n\n.tiktok-vocab-content {\n    text-align: center;\n    width: 100%;\n    z-index: 2;\n    margin-top: 90px; /* Increased space for mode selector */\n    padding-top: 15px;\n}\n\n.vocab-word-large {\n    font-size: 48px;\n    font-weight: 700;\n    margin-bottom: 15px;\n    text-shadow: 0 2px 8px rgba(0,0,0,0.3);\n    transition: opacity 0.15s ease;\n}\n\n.vocab-pronunciation-large {\n    font-size: 20px;\n    opacity: 0.9;\n    margin-bottom: 40px; /* Increased spacing to compensate for removed definition */\n    font-style: italic;\n    transition: opacity 0.15s ease;\n}\n\n/* Removed .vocab-definition-large to simplify the vocabulary display */\n\n.translations-container {\n    background: rgba(255,255,255,0.1);\n    border-radius: 15px;\n    padding: 20px;\n    margin-bottom: 25px;\n    backdrop-filter: blur(10px);\n    animation: fadeInUp 0.6s ease-out 0.3s both;\n}\n\n.translation-item {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 8px 0;\n    border-bottom: 1px solid rgba(255,255,255,0.1);\n}\n\n.translation-item:last-child {\n    border-bottom: none;\n}\n\n.translation-lang {\n    font-size: 20px;\n    min-width: 30px;\n}\n\n.translation-word {\n    font-size: 16px;\n    font-weight: 600;\n    flex: 1;\n    text-align: center;\n}\n\n.translation-pronunciation {\n    font-size: 14px;\n    opacity: 0.8;\n    font-style: italic;\n}\n\n.vocab-meta-large {\n    display: flex;\n    gap: 15px;\n    justify-content: center;\n    margin-bottom: 20px;\n    animation: fadeInUp 0.6s ease-out 0.4s both;\n}\n\n.difficulty-badge-large {\n    padding: 8px 16px;\n    border-radius: 20px;\n    font-size: 14px;\n    font-weight: 600;\n    background: rgba(255,255,255,0.2);\n    backdrop-filter: blur(5px);\n}\n\n.category-badge {\n    padding: 8px 16px;\n    border-radius: 20px;\n    font-size: 14px;\n    background: rgba(255,255,255,0.15);\n    backdrop-filter: blur(5px);\n}\n\n.swipe-indicator {\n    position: absolute;\n    bottom: 20px;\n    left: 0;\n    right: 0;\n    text-align: center;\n    animation: fadeInUp 0.6s ease-out 0.5s both;\n}\n\n.swipe-hint {\n    font-size: 12px;\n    opacity: 0.7;\n    margin-bottom: 10px;\n}\n\n.session-stats {\n    display: flex;\n    justify-content: center;\n    gap: 15px;\n    margin-bottom: 10px;\n}\n\n.stat {\n    font-size: 12px;\n    background: rgba(255,255,255,0.2);\n    padding: 4px 8px;\n    border-radius: 10px;\n    backdrop-filter: blur(5px);\n}\n\n.progress-dots {\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n}\n\n.dot {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: rgba(255,255,255,0.3);\n    transition: all 0.3s ease;\n}\n\n.dot.active {\n    background: white;\n    transform: scale(1.2);\n}\n\n/* Side action buttons */\n.side-actions {\n    position: absolute;\n    right: 15px;\n    top: 60%; /* Moved down to avoid text overlap */\n    transform: translateY(-50%);\n    display: flex;\n    flex-direction: column;\n    gap: 20px;\n    z-index: 3;\n    transition: opacity 0.3s ease, transform 0.3s ease;\n}\n\n.side-actions.auto-hidden {\n    opacity: 0;\n    transform: translateY(-50%) translateX(20px);\n    pointer-events: none;\n}\n\n.action-btn {\n    width: 50px;\n    height: 50px;\n    border-radius: 50%;\n    border: none;\n    background: rgba(255,255,255,0.2);\n    backdrop-filter: blur(10px);\n    color: white;\n    font-size: 20px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 4px 16px rgba(0,0,0,0.2);\n}\n\n.action-btn:hover {\n    background: rgba(255,255,255,0.3);\n    transform: scale(1.1);\n}\n\n.action-btn:active {\n    transform: scale(0.95);\n}\n\n/* Vocabulary mode selector */\n.vocabulary-mode-selector {\n    position: absolute;\n    top: 10px;\n    left: 50%;\n    transform: translateX(-50%);\n    display: flex;\n    gap: 8px;\n    z-index: 10;\n    background: rgba(255, 255, 255, 0.15);\n    backdrop-filter: blur(10px);\n    border-radius: 20px;\n    padding: 6px;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.mode-btn {\n    padding: 8px 12px;\n    border: none;\n    border-radius: 14px;\n    background: transparent;\n    color: rgba(255, 255, 255, 0.8);\n    font-size: 12px;\n    font-weight: 500;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.mode-btn:hover {\n    background: rgba(255, 255, 255, 0.2);\n    color: white;\n}\n\n.mode-btn.active {\n    background: rgba(255, 255, 255, 0.9);\n    color: #667eea;\n    font-weight: 600;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n/* Mode change notification */\n.mode-change-notification {\n    position: absolute;\n    top: 60px;\n    left: 50%;\n    transform: translateX(-50%);\n    background: rgba(255, 255, 255, 0.2);\n    backdrop-filter: blur(10px);\n    border-radius: 12px;\n    padding: 8px 16px;\n    color: white;\n    font-size: 12px;\n    font-weight: 500;\n    white-space: nowrap;\n    opacity: 0;\n    transition: all 0.3s ease;\n    z-index: 9;\n    border: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.mode-change-notification.show {\n    opacity: 1;\n    transform: translateX(-50%) translateY(0);\n}\n\n.nav-btn {\n    background: rgba(102, 126, 234, 0.9);\n    color: white;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n}\n\n.nav-btn:hover {\n    background: rgba(102, 126, 234, 1);\n    transform: scale(1.05);\n}\n\n/* Auto-progression indicator */\n/* Auto-progression indicator removed for cleaner display */\n\n/* Fade in animations */\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.vocab-card {\n    background: white;\n    border: 1px solid #e9ecef;\n    border-radius: 12px;\n    padding: 15px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n}\n\n.vocab-word {\n    font-size: 18px;\n    font-weight: 600;\n    color: #333;\n    margin-bottom: 5px;\n}\n\n.vocab-pronunciation {\n    color: #667eea;\n    font-style: italic;\n    margin-bottom: 8px;\n}\n\n.vocab-definition {\n    color: #6c757d;\n    margin-bottom: 10px;\n}\n\n.vocab-meta {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.difficulty-badge {\n    padding: 4px 8px;\n    border-radius: 12px;\n    font-size: 11px;\n    font-weight: 600;\n}\n\n.difficulty-beginner { background: #d4edda; color: #155724; }\n.difficulty-intermediate { background: #fff3cd; color: #856404; }\n.difficulty-advanced { background: #f8d7da; color: #721c24; }\n\n.pronunciation-practice {\n    max-width: 100%;\n}\n\n.target-word {\n    background: #f8f9fa;\n    padding: 20px;\n    border-radius: 12px;\n    text-align: center;\n    margin-bottom: 20px;\n}\n\n#target-text {\n    font-size: 24px;\n    font-weight: bold;\n    color: #333;\n    margin-bottom: 8px;\n}\n\n#target-pronunciation {\n    color: #667eea;\n    font-style: italic;\n    margin-bottom: 15px;\n}\n\n.play-btn {\n    background: #667eea;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 20px;\n    cursor: pointer;\n    font-size: 14px;\n}\n\n.practice-area {\n    margin-bottom: 20px;\n}\n\n.speech-input {\n    width: 100%;\n    padding: 15px;\n    border: 2px solid #e9ecef;\n    border-radius: 12px;\n    font-size: 16px;\n    margin-bottom: 15px;\n    transition: all 0.3s ease;\n    background: rgba(255,255,255,0.9);\n    backdrop-filter: blur(5px);\n}\n\n.speech-input:focus {\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n    outline: none;\n    background: white;\n}\n\n.analyze-btn {\n    width: 100%;\n    background: #28a745;\n    color: white;\n    border: none;\n    padding: 15px;\n    border-radius: 12px;\n    font-size: 16px;\n    font-weight: 600;\n    cursor: pointer;\n}\n\n.result-area {\n    background: #f8f9fa;\n    border-radius: 12px;\n    padding: 20px;\n}\n\n.result-card {\n    text-align: center;\n}\n\n.accuracy-score {\n    font-size: 36px;\n    font-weight: bold;\n    color: #28a745;\n    margin-bottom: 10px;\n}\n\n.grade {\n    font-size: 24px;\n    font-weight: bold;\n    padding: 8px 16px;\n    border-radius: 20px;\n    background: #28a745;\n    color: white;\n    display: inline-block;\n    margin-bottom: 15px;\n}\n\n.feedback {\n    color: #333;\n    font-size: 16px;\n    line-height: 1.5;\n}\n\n.progress-overview {\n    display: grid;\n    gap: 20px;\n    margin-bottom: 30px;\n}\n\n.progress-card {\n    background: white;\n    border: 1px solid #e9ecef;\n    border-radius: 12px;\n    padding: 20px;\n}\n\n.progress-chart {\n    margin-top: 15px;\n}\n\n.chart-bar {\n    height: 12px;\n    background: #e9ecef;\n    border-radius: 6px;\n    overflow: hidden;\n    margin-bottom: 8px;\n}\n\n.chart-fill {\n    height: 100%;\n    background: #667eea;\n    transition: width 0.5s ease;\n    border-radius: 6px;\n}\n\n.chart-fill.pronunciation { background: #28a745; }\n.chart-fill.vocabulary { background: #ffc107; }\n\n.chart-label {\n    text-align: right;\n    font-weight: 600;\n    color: #667eea;\n}\n\n.study-history {\n    background: white;\n    border: 1px solid #e9ecef;\n    border-radius: 12px;\n    padding: 20px;\n}\n\n.history-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 12px 0;\n    border-bottom: 1px solid #f8f9fa;\n}\n\n.history-item:last-child {\n    border-bottom: none;\n}\n\n.history-date {\n    font-weight: 600;\n    color: #333;\n}\n\n.history-activity {\n    color: #6c757d;\n}\n\n.history-score {\n    color: #28a745;\n    font-weight: 600;\n}\n\n.settings-group {\n    background: white;\n    border: 1px solid #e9ecef;\n    border-radius: 12px;\n    padding: 20px;\n    margin-bottom: 20px;\n}\n\n.settings-group h3 {\n    margin-bottom: 15px;\n    color: #333;\n}\n\n.setting-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n}\n\n.setting-item label {\n    font-weight: 500;\n}\n\n.setting-item input[type=\"range\"] {\n    width: 100px;\n    margin: 0 10px;\n}\n\n.setting-item select {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n}\n\n.premium-card {\n    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);\n    padding: 20px;\n    border-radius: 12px;\n    text-align: center;\n}\n\n.premium-card h4 {\n    margin-bottom: 10px;\n    color: #333;\n}\n\n.premium-btn {\n    background: #333;\n    color: white;\n    border: none;\n    padding: 12px 24px;\n    border-radius: 20px;\n    font-weight: 600;\n    cursor: pointer;\n    margin-top: 10px;\n}\n\n/* Responsive design */\n@media (max-width: 480px) {\n    #app {\n        max-width: 100%;\n        margin: 0;\n    }\n    \n    .stats-grid, .action-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .vocab-word-large {\n        font-size: 36px;\n    }\n    \n    .tiktok-vocab-card {\n        padding: 15px 10px;\n    }\n    \n    .tiktok-vocab-content {\n        margin-top: 60px; /* Reduce margin on small screens */\n    }\n    \n    .vocabulary-mode-selector {\n        top: 15px; /* Move closer to top on small screens */\n        gap: 6px;\n        padding: 4px;\n    }\n    \n    .mode-btn {\n        padding: 6px 8px;\n        font-size: 11px;\n    }\n    \n    .side-actions {\n        right: 10px;\n    }\n    \n    .action-btn {\n        width: 45px;\n        height: 45px;\n        font-size: 18px;\n    }\n}\n\n/* Landscape mode adjustments */\n@media (orientation: landscape) and (max-height: 500px) {\n    .tiktok-vocabulary-container {\n        height: calc(100vh - 120px);\n    }\n    \n    .tiktok-vocab-content {\n        margin-top: 50px; /* Reduce margin in landscape mode */\n    }\n    \n    .vocabulary-mode-selector {\n        top: 10px; /* Move closer to top in landscape */\n    }\n    \n    .vocab-word-large {\n        font-size: 32px;\n    }\n    \n    .translations-container {\n        padding: 15px;\n        margin-bottom: 15px;\n    }\n}\n\n/* High refresh rate displays */\n@media (prefers-reduced-motion: no-preference) {\n    .tab-content, .tiktok-vocabulary-container {\n        transition-duration: 0.2s;\n    }\n    \n    .action-btn {\n        transition-duration: 0.2s;\n    }\n    \n    .toast-notification {\n        transition-duration: 0.2s;\n    }\n}\n\n/* Engagement enhancement styles */\n.tiktok-vocab-card:hover {\n    transform: scale(1.02);\n}\n\n.translation-item {\n    transition: all 0.3s ease;\n}\n\n.translation-item:hover {\n    background: rgba(255,255,255,0.1);\n    border-radius: 8px;\n    padding: 12px 8px;\n}\n\n/* Progress indicator enhancement */\n.dot {\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    cursor: pointer;\n}\n\n.dot:hover {\n    background: rgba(255,255,255,0.6);\n    transform: scale(1.5);\n}\n\n/* Add subtle bounce to active elements */\n.action-btn:active {\n    animation: bounce 0.3s ease;\n}\n\n@keyframes bounce {\n    0%, 100% { transform: scale(0.95); }\n    50% { transform: scale(1.05); }\n}\n\n/* Toast notification styles */\n.toast-notification {\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%) scale(0.8);\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 15px 25px;\n    border-radius: 25px;\n    font-size: 14px;\n    font-weight: 600;\n    z-index: 1000;\n    opacity: 0;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    backdrop-filter: blur(10px);\n    box-shadow: 0 8px 32px rgba(0,0,0,0.3);\n    text-align: center;\n    white-space: pre-line;\n    max-width: 300px;\n}\n\n.toast-notification.show {\n    opacity: 1;\n    transform: translate(-50%, -50%) scale(1);\n}\n\n/* Enhanced action button styles */\n.action-btn {\n    position: relative;\n    overflow: hidden;\n}\n\n.action-btn::before {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 0;\n    height: 0;\n    background: rgba(255,255,255,0.4);\n    border-radius: 50%;\n    transform: translate(-50%, -50%);\n    transition: width 0.3s ease, height 0.3s ease;\n}\n\n.action-btn:active::before {\n    width: 100px;\n    height: 100px;\n}\n\n/* Pulsing animation for favorite button when favorited */\n.favorite-btn:has-text(\"‚ù§Ô∏è\") {\n    animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n    0% { transform: scale(1); }\n    50% { transform: scale(1.1); }\n    100% { transform: scale(1); }\n}\n\n/* Improved swipe preview effects */\n.tiktok-vocabulary-container.swipe-preview {\n    filter: brightness(0.8) blur(1px);\n}\n\n/* Loading state */\n.tiktok-vocab-card.loading {\n    pointer-events: none;\n}\n\n.tiktok-vocab-card.loading::after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(90deg, \n        transparent 0%, \n        rgba(255,255,255,0.2) 50%, \n        transparent 100%);\n    animation: shimmer 1.5s infinite;\n}\n\n@keyframes shimmer {\n    0% { transform: translateX(-100%); }\n    100% { transform: translateX(100%); }\n}\n\n/* Reduced motion preferences */\n@media (prefers-reduced-motion: reduce) {\n    .tab-content, .tiktok-vocabulary-container, .action-btn {\n        transition: none;\n    }\n    \n    .vocab-word-large, .vocab-pronunciation-large, \n    .translations-container, \n    .vocab-meta-large, .swipe-indicator {\n        animation: none;\n    }\n    \n    .progress-fill {\n        animation: none;\n    }\n    \n    .toast-notification {\n        transition: opacity 0.1s ease;\n    }\n    \n    .action-btn::before {\n        display: none;\n    }\n}\n\n/* Dark mode support */\n@media (prefers-color-scheme: dark) {\n    .tab-nav {\n        background: #2d3748;\n        border-bottom: 1px solid #4a5568;\n    }\n    \n    .tab-btn {\n        color: #e2e8f0;\n    }\n    \n    .tab-btn.active {\n        background: #4a5568;\n        color: #667eea;\n    }\n}\n\n/* Multilingual LTV-focused Dashboard Styles */\n\n/* Streak Section */\n.streak-section {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 12px;\n    margin-bottom: 20px;\n}\n\n.streak-card, .daily-goal-card {\n    background: linear-gradient(135deg, #ff6b6b, #ffa500);\n    color: white;\n    padding: 16px;\n    border-radius: 16px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);\n}\n\n.daily-goal-card {\n    background: linear-gradient(135deg, #4ecdc4, #44a08d);\n    box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);\n}\n\n.streak-icon, .goal-icon {\n    font-size: 28px;\n}\n\n.streak-count, .goal-progress {\n    font-size: 24px;\n    font-weight: bold;\n    line-height: 1;\n}\n\n.streak-label, .goal-label {\n    font-size: 12px;\n    opacity: 0.9;\n}\n\n/* Languages Section */\n.languages-section {\n    margin-bottom: 20px;\n}\n\n.section-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 12px;\n}\n\n.section-header h3 {\n    margin: 0;\n    font-size: 18px;\n    color: #333;\n}\n\n.view-all-btn, .leaderboard-btn {\n    background: #6c5ce7;\n    color: white;\n    border: none;\n    padding: 6px 12px;\n    border-radius: 12px;\n    font-size: 12px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.view-all-btn:hover, .leaderboard-btn:hover {\n    background: #5a4fcf;\n    transform: translateY(-1px);\n}\n\n.language-cards {\n    display: flex;\n    gap: 12px;\n    overflow-x: auto;\n    padding-bottom: 8px;\n}\n\n.language-card {\n    background: linear-gradient(135deg, #667eea, #764ba2);\n    color: white;\n    padding: 16px;\n    border-radius: 12px;\n    min-width: 140px;\n    cursor: pointer;\n    transition: transform 0.2s ease;\n    box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);\n}\n\n.language-card:hover {\n    transform: translateY(-2px);\n}\n\n.language-flag {\n    font-size: 24px;\n    margin-bottom: 8px;\n}\n\n.language-name {\n    font-weight: bold;\n    font-size: 14px;\n    margin-bottom: 4px;\n}\n\n.language-progress {\n    font-size: 12px;\n    opacity: 0.9;\n}\n\n.language-level {\n    background: rgba(255, 255, 255, 0.2);\n    padding: 2px 8px;\n    border-radius: 8px;\n    font-size: 10px;\n    margin-top: 4px;\n    display: inline-block;\n}\n\n/* Add New Language Section */\n.add-language-section {\n    margin-bottom: 20px;\n}\n\n.add-language-card {\n    background: linear-gradient(135deg, #a8edea, #fed6e3);\n    padding: 20px;\n    border-radius: 16px;\n    display: flex;\n    align-items: center;\n    gap: 16px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    border: 2px dashed rgba(102, 126, 234, 0.3);\n}\n\n.add-language-card:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);\n    border-color: #667eea;\n}\n\n.add-icon {\n    font-size: 32px;\n    animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n    0%, 100% { transform: scale(1); }\n    50% { transform: scale(1.1); }\n}\n\n.add-content h4 {\n    margin: 0 0 4px 0;\n    font-size: 16px;\n    color: #333;\n}\n\n.add-content p {\n    margin: 0 0 8px 0;\n    font-size: 12px;\n    color: #666;\n}\n\n.cta-badge {\n    background: #00b894;\n    color: white;\n    padding: 4px 12px;\n    border-radius: 12px;\n    font-size: 10px;\n    font-weight: bold;\n    display: inline-block;\n}\n\n.arrow-icon {\n    font-size: 20px;\n    color: #667eea;\n    margin-left: auto;\n}\n\n/* Premium Section */\n.premium-section {\n    margin-bottom: 20px;\n}\n\n.premium-card {\n    background: linear-gradient(135deg, #ffecd2, #fcb69f);\n    padding: 20px;\n    border-radius: 16px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    border: 2px solid #ffd700;\n    position: relative;\n    overflow: hidden;\n}\n\n.premium-card::before {\n    content: '';\n    position: absolute;\n    top: -50%;\n    left: -50%;\n    width: 200%;\n    height: 200%;\n    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);\n    transform: rotate(45deg);\n    animation: shine 3s infinite;\n}\n\n@keyframes shine {\n    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }\n    50% { transform: translateX(100%) translateY(100%) rotate(45deg); }\n    100% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }\n}\n\n.premium-card:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);\n}\n\n.premium-badge {\n    background: linear-gradient(135deg, #ffd700, #ffed4e);\n    color: #333;\n    padding: 4px 12px;\n    border-radius: 12px;\n    font-size: 12px;\n    font-weight: bold;\n    display: inline-block;\n    margin-bottom: 12px;\n}\n\n.premium-content h4 {\n    margin: 0 0 12px 0;\n    font-size: 18px;\n    color: #333;\n}\n\n.premium-features {\n    list-style: none;\n    padding: 0;\n    margin: 0 0 16px 0;\n}\n\n.premium-features li {\n    padding: 4px 0;\n    font-size: 14px;\n    color: #555;\n}\n\n.premium-cta {\n    background: #e17055;\n    color: white;\n    padding: 12px 20px;\n    border-radius: 25px;\n    font-weight: bold;\n    text-align: center;\n    font-size: 14px;\n}\n\n/* Social Section */\n.social-section {\n    margin-bottom: 20px;\n}\n\n.social-stats {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: 12px;\n}\n\n.social-card {\n    background: linear-gradient(135deg, #74b9ff, #0984e3);\n    color: white;\n    padding: 16px;\n    border-radius: 12px;\n    text-align: center;\n    box-shadow: 0 3px 10px rgba(116, 185, 255, 0.3);\n}\n\n.social-icon {\n    font-size: 24px;\n    margin-bottom: 8px;\n}\n\n.social-value {\n    font-size: 18px;\n    font-weight: bold;\n    line-height: 1;\n}\n\n.social-label {\n    font-size: 10px;\n    opacity: 0.9;\n    margin-top: 4px;\n}\n\n/* Enhanced Action Cards */\n.action-card.primary {\n    background: linear-gradient(135deg, #fd79a8, #e84393);\n    color: white;\n    transform: scale(1.02);\n    box-shadow: 0 6px 20px rgba(253, 121, 168, 0.4);\n}\n\n.action-card.primary:hover {\n    transform: scale(1.05) translateY(-2px);\n    box-shadow: 0 8px 25px rgba(253, 121, 168, 0.5);\n}\n\n/* Enhanced Mobile Responsive for New Dashboard */\n@media (max-width: 480px) {\n    .streak-section {\n        grid-template-columns: 1fr;\n        gap: 8px;\n    }\n\n    .social-stats {\n        grid-template-columns: 1fr;\n        gap: 8px;\n    }\n\n    .language-cards {\n        flex-direction: column;\n    }\n\n    .language-card {\n        min-width: auto;\n    }\n    \n    .add-language-card, .premium-card {\n        padding: 16px;\n    }\n    \n    .add-content h4, .premium-content h4 {\n        font-size: 14px;\n    }\n}","size_bytes":27358}},"version":1}